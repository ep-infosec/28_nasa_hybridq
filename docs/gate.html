<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>hybridq.gate API documentation</title>
<meta name="description" content="Author: Salvatore Mandra (salvatore.mandra@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.gate</code></h1>
</header>
<section id="section-intro">
<p>Author: Salvatore Mandra (salvatore.mandra@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Salvatore Mandra (salvatore.mandra@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
from opt_einsum import get_symbol, contract
from copy import copy, deepcopy
from scipy.linalg import expm, sqrtm, fractional_matrix_power
from hybridq.utils import sort, argsort, svd
from warnings import warn
import numpy as np

_available_gates = {
    &#39;I&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: np.array(np.eye(2))
    },
    &#39;U3&#39;: {
        &#39;n_qubits&#39;:
            1,
        &#39;n_params&#39;:
            3,
        &#39;U_gen&#39;:
            lambda t, p, l: np.array(
                [[np.cos(t / 2), -np.exp(1j * l) * np.sin(t / 2)],
                 [
                     np.exp(1j * p) * np.sin(t / 2),
                     np.exp(1j * (l + p)) * np.cos(t / 2)
                 ]])
    },
    &#39;H&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: np.array([[1, 1], [1, -1]]) / np.sqrt(2)
    },
    &#39;X&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: np.array([[0, 1], [1, 0]])
    },
    &#39;Y&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: np.array([[0, -1j], [1j, 0]])
    },
    &#39;Z&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: np.array([[1, 0], [0, -1]])
    },
    &#39;P&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: np.array([[1, 0], [0, 1j]])
    },
    &#39;T&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]])
    },
    &#39;SQRT_X&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: sqrtm(np.array([[0, 1], [1, 0]]))
    },
    &#39;SQRT_Y&#39;: {
        &#39;n_qubits&#39;: 1,
        &#39;n_params&#39;: 0,
        &#39;U_gen&#39;: lambda: sqrtm(np.array([[0, -1j], [1j, 0]]))
    },
    &#39;RX&#39;: {
        &#39;n_qubits&#39;:
            1,
        &#39;n_params&#39;:
            1,
        &#39;U_gen&#39;:
            lambda r: np.array(expm(-1j * np.array([[0, 1], [1, 0]]) * r / 2))
    },
    &#39;RY&#39;: {
        &#39;n_qubits&#39;:
            1,
        &#39;n_params&#39;:
            1,
        &#39;U_gen&#39;:
            lambda r: np.array(expm(-1j * np.array([[0, -1j], [1j, 0]]) * r / 2)
                              )
    },
    &#39;RZ&#39;: {
        &#39;n_qubits&#39;:
            1,
        &#39;n_params&#39;:
            1,
        &#39;U_gen&#39;:
            lambda r: np.array(expm(-1j * np.array([[1, 0], [0, -1]]) * r / 2))
    },
    &#39;R_PI_2&#39;: {
        &#39;n_qubits&#39;:
            1,
        &#39;n_params&#39;:
            1,
        &#39;U_gen&#39;:
            lambda phi: np.array([[1, -1j * np.exp(-1j * phi)],
                                  [-1j * np.exp(1j * phi), 1]]) / np.sqrt(2)
    },
    &#39;CPHASE&#39;: {
        &#39;n_qubits&#39;:
            2,
        &#39;n_params&#39;:
            1,
        &#39;U_gen&#39;:
            lambda p: np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0],
                                [0, 0, 0, np.exp(1j * p)]])
    },
    &#39;CX&#39;: {
        &#39;n_qubits&#39;:
            2,
        &#39;n_params&#39;:
            0,
        &#39;U_gen&#39;:
            lambda: np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1],
                              [0, 0, 1, 0]])
    },
    &#39;CZ&#39;: {
        &#39;n_qubits&#39;:
            2,
        &#39;n_params&#39;:
            0,
        &#39;U_gen&#39;:
            lambda: np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0],
                              [0, 0, 0, -1]])
    },
    &#39;ZZ&#39;: {
        &#39;n_qubits&#39;:
            2,
        &#39;n_params&#39;:
            0,
        &#39;U_gen&#39;:
            lambda: np.array([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0],
                              [0, 0, 0, 1]])
    },
    &#39;FSIM&#39;: {
        &#39;n_qubits&#39;:
            2,
        &#39;n_params&#39;:
            2,
        &#39;U_gen&#39;:
            lambda t, p: np.array(
                [[1, 0, 0, 0], [0, np.cos(t), -1j * np.sin(t), 0],
                 [0, -1j * np.sin(t), np.cos(t), 0], [0, 0, 0,
                                                      np.exp(-1j * p)]])
    },
    &#39;SWAP&#39;: {
        &#39;n_qubits&#39;:
            2,
        &#39;n_params&#39;:
            0,
        &#39;U_gen&#39;:
            lambda: np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0],
                              [0, 0, 0, 1]])
    },
    &#39;ISWAP&#39;: {
        &#39;n_qubits&#39;:
            2,
        &#39;n_params&#39;:
            0,
        &#39;U_gen&#39;:
            lambda: np.array([[1, 0, 0, 0], [0, 0, 1j, 0], [0, 1j, 0, 0],
                              [0, 0, 0, 1]])
    },
    &#39;SQRT_ISWAP&#39;: {
        &#39;n_qubits&#39;:
            2,
        &#39;n_params&#39;:
            0,
        &#39;U_gen&#39;:
            lambda: sqrtm(
                np.array([[1, 0, 0, 0], [0, 0, 1j, 0], [0, 1j, 0, 0],
                          [0, 0, 0, 1]]))
    },
}

_gate_aliases = {
    &#39;ID&#39;: &#39;I&#39;,
    &#39;S&#39;: &#39;P&#39;,
    &#39;Z_1_2&#39;: &#39;P&#39;,
    &#39;SQRT_Z&#39;: &#39;P&#39;,
    &#39;CNOT&#39;: &#39;CX&#39;,
    &#39;X_1_2&#39;: &#39;SQRT_X&#39;,
    &#39;Y_1_2&#39;: &#39;SQRT_Y&#39;,
    &#39;FS&#39;: &#39;FSIM&#39;,
}

_clifford_gates = [
    &#39;I&#39;,
    &#39;H&#39;,
    &#39;X&#39;,
    &#39;Y&#39;,
    &#39;Z&#39;,
    &#39;P&#39;,
    &#39;SQRT_X&#39;,
    &#39;SQRT_Y&#39;,
    &#39;CX&#39;,
    &#39;CZ&#39;,
    &#39;ZZ&#39;,
    &#39;SWAP&#39;,
    &#39;ISWAP&#39;,
]


class Gate(object):
    &#34;&#34;&#34;
    Class representing a single gate.

    Attributes
    ----------
    name: str
        Name of `Gate`.
    qubits: list[any], optional
        List of qubits `Gate` is acting on.
    params: list[any], optional
        List of parameters to define `Gate`.
    power: float, optional
        The power the unitary matrix of `Gate` is elevated to.
    tags: dict[any, any], optional
        Dictionary of tags.
    U: list[list[any]], optional
        If `name` is `MATRIX`, its unitary matrix must be provided using `U`.
    check_unitary: bool, optional
        If `U` is provided, check that `U` is unitary. Otherwise, raise
        `ValueError`.

    Example
    -------
    &gt;&gt;&gt; g = Gate(&#39;RX&#39;, qubits=[1], params=[3.2])**3.4
    &gt;&gt;&gt; g.unitary()
    array([[6.65087527e-01+1.10596489e-16j, 6.50125829e-17+7.46765413e-01j],
           [9.71433860e-18+7.46765413e-01j, 6.65087527e-01+1.05739319e-16j]])

    It is also possible to specify gates by using their matrix representation:
    &gt;&gt;&gt; g = Gate(&#39;MATRIX&#39;, qubits=[1], U=[[0,-1j], [1j, 0]])
    &gt;&gt;&gt; g
    Gate(name=MATRIX, qubits=[1], U=np.array(shape=(2, 2), dtype=complex128))
    &gt;&gt;&gt; g.isclose(Gate(&#39;Y&#39;)) # Acting on different qubits
    False
    &gt;&gt;&gt; g.isclose(Gate(&#39;Y&#39;, qubits=[1])) # Acting on the same qubits
    True
    &#34;&#34;&#34;

    def __setattr__(self, *args) -&gt; None:
        raise ValueError(&#34;Operation not permitted.&#34;)

    def __delattr__(self, *args) -&gt; None:
        raise ValueError(&#34;Operation not permitted.&#34;)

    def __init__(self,
                 name: str,
                 qubits: iter[any] = None,
                 params: iter[any] = None,
                 power: any = 1,
                 tags: dict[any, any] = None,
                 U: list[list[any]] = None,
                 check_unitary: bool = False) -&gt; None:

        # Convert name to upper
        name = name.upper()

        # Check if name is an alias
        if name in _gate_aliases:
            warn(
                f&#34;&#39;{name}&#39; is an alias for &#39;{_gate_aliases[name]}&#39;. Using Gate(name=&#39;{_gate_aliases[name]}&#39;).&#34;
            )
            name = _gate_aliases[name]

        # Check if name is in _available_qubits
        if name not in _available_gates and name != &#39;MATRIX&#39;:
            raise ValueError(f&#34;Gate(name=&#39;{name}&#39;) not available.&#34;)

        # If MATRIX, the unitary matrix must be provided
        if name == &#39;MATRIX&#39;:
            # Check that matrix representation is present
            if U is None:
                raise ValueError(&#34;Gate(name=&#39;MATRIX&#39;) requires &#39;U&#39;.&#34;)

            # Assign U ..
            object.__setattr__(self, &#39;U&#39;, np.array(U))

            # .. and make it read-only
            self.U.flags[&#39;WRITEABLE&#39;] = False

            # Check shape
            _x, _y = self.U.shape
            if _x != _y or not np.isclose(np.log2(_x), int(np.log2(_x))):
                raise ValueError(
                    f&#34;&#39;U&#39; must be a quadratic matrix of shape (2^n, 2^n).&#34;)

            # Check if unitary
            if check_unitary:
                if not np.allclose(self.U.dot(self.U.T.conj()),
                                   np.eye(len(self.U))) or not np.allclose(
                                       np.eye(len(self.U)),
                                       self.U.dot(self.U.T.conj())):
                    raise ValueError(f&#34;&#39;U&#39; must be a unitary matrix.&#34;)

        # Set gate
        object.__setattr__(self, &#39;name&#39;, str(name))

        # Update qubits
        self._on(qubits)

        # Update params
        self._set_params(params)

        # Set power
        self._set_power(power)

        # Update tags
        self._set_tags(tags)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Return string representation of Gate.
        &#34;&#34;&#34;

        _str = f&#34;Gate(name=&#39;{self.name}&#39;&#34;
        if hasattr(self, &#39;qubits&#39;):
            _str += f&#34;, qubits={self.qubits}&#34;
        if hasattr(self, &#39;params&#39;) and len(self.params):
            _str += f&#34;, params={self.params}&#34;
        if self.name == &#39;MATRIX&#39;:
            _str += f&#39;, U=np.array(shape={self.U.shape}, dtype={str(self.U.dtype)})&#39;
        if hasattr(self, &#39;tags&#39;) and self.tags:
            _str += f&#39;, tags={self.tags}&#39;
        _str += &#39;)&#39;
        if self.power != 1:
            _str += f&#39;**{self.power}&#39;
        return _str

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Return string representation of Gate.
        &#34;&#34;&#34;

        return self.__str__()

    def __neq__(self, g: Gate) -&gt; bool:
        return not (self.__eq__(g))

    def __eq__(self, g: Gate) -&gt; bool:
        &#34;&#34;&#34;
        Two gates are equal if everything matches (including tags).
        &#34;&#34;&#34;

        # If keys don&#39;t match, the gates differ
        if self.__dict__.keys() != g.__dict__.keys():

            return False

        else:

            # Check key by key
            for k, v in self.__dict__.items():

                # If np.ndarray, return False if at least one element differs
                if type(v) == np.ndarray:
                    if np.any(v != g.__dict__[k]):
                        return False

                # Otherwise, return False if the two values are not equivalent
                else:
                    if v != g.__dict__[k]:
                        return False

            return True

    def isclose(self, gate: Gate, atol: float = 1e-8) -&gt; bool:
        &#34;&#34;&#34;
        Determine if the unitary matrix of `gate` is close within an absolute
        tollerance. If the gates are acting on a different set of qubits,
        `isclose` will return `False`.

        Parameters
        ----------
        gate: Gate
            Gate to compare with.
        atol: float, optional
            Absolute tollerance.

        Returns
        -------
        bool
            `True` if the two gates are close withing the given absolute
            tollerance, otherwise `False`.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;X&#39;, qubits=[1]).isclose(Gate(&#39;Y&#39;, qubits=[1]))
        False
        &gt;&gt;&gt; Gate(&#39;Y&#39;, qubits=[1]).isclose(Gate(&#39;Y&#39;, qubits=[2]))
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1]).isclose(Gate(&#39;RX&#39;, qubits=[1]))
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[1.23]).isclose(Gate(&#39;RX&#39;, qubits=[1]))
        False
        &#34;&#34;&#34;

        if hasattr(self, &#39;qubits&#39;) == hasattr(gate, &#39;qubits&#39;):

            # The gates differ if they act on a different set of qubits
            if hasattr(self,
                       &#39;qubits&#39;) and sort(self.qubits) != sort(gate.qubits):
                return False

            # If the gates have the same name, we can avoid to create unitaries if there is a match
            if self.name == gate.name and self.name != &#39;MATRIX&#39; and np.isclose(
                    float(self.power), float(gate.power), atol=atol):
                if not hasattr(self, &#39;qubits&#39;) or self.qubits == gate.qubits:
                    if hasattr(self, &#39;params&#39;) == hasattr(gate, &#39;params&#39;):
                        if not hasattr(self, &#39;params&#39;) or np.allclose(
                            [float(p) for p in self.params],
                            [float(p) for p in gate.params],
                                atol=atol):
                            return True

            # Get unitaries
            _U1 = self.unitary() if self.name == &#39;MATRIX&#39; or _available_gates[
                self.name][&#39;n_params&#39;] == 0 or hasattr(self, &#39;params&#39;) else None
            _U2 = gate.unitary(
                order=self.qubits if hasattr(self, &#39;qubits&#39;) else None
            ) if gate.name == &#39;MATRIX&#39; or _available_gates[
                gate.name][&#39;n_params&#39;] == 0 or hasattr(gate, &#39;params&#39;) else None

            # If either unitary does not exist, the two gates differ
            if _U1 is None or _U2 is None:
                return False
            else:
                return np.allclose(_U1, _U2, atol=atol)

        else:

            return False

    def __pow__(self, p: any) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate`**p.
        &#34;&#34;&#34;

        return self.set_power(self.power * p, inplace=False)

    def _inv(self) -&gt; None:
        &#34;&#34;&#34;
        Modify `Gate` to its inverse.
        &#34;&#34;&#34;

        self.inv(inplace=True)

    def inv(self, *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return inverse of `Gate`. If `inplace` is `True`, `Gate` is modified in place.

        Parameters
        ----------
        inplace: bool, optional
            If `True`, Gate is modified in place. Otherwise, a new
            `Gate` is returned.

        Returns
        -------
        Gate
            Inverse of `Gate`. If `True`, `Gate` is modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;P&#39;)
        Gate(name=P)
        &gt;&gt;&gt; Gate(&#39;P&#39;).inv()
        Gate(name=P)**-1
        &gt;&gt;&gt; Gate(&#39;P&#39;).unitary().dot(Gate(&#39;P&#39;).inv().unitary())
        array([[1.+0.j, 0.+0.j],
               [0.+0.j, 1.+0.j]])
        &#34;&#34;&#34;

        return self.set_power(self.power * -1, inplace=inplace)

    def _on(self, qubits: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Set `qubits` to `Gate`.
        &#34;&#34;&#34;

        self.on(qubits, inplace=True)

    def on(self, qubits: iter[any], *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` applied to `qubits`. If `inplace` is `True`, `Gate` is
        modified in place.

        Parameters
        ----------
        qubits: iter[any]
            Qubits the new Gate will act on.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate`
            is returned.

        Returns
        -------
        Gate
            New `Gate` acting on `qubits`. If `inplace` is `True`, `Gate` is
            modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;H&#39;)
        Gate(name=H)
        &gt;&gt;&gt; Gate(&#39;H&#39;).on([3])
        Gate(name=H, qubits=[3])
        &#34;&#34;&#34;

        # Convert qubits to list
        if qubits is not None:
            qubits = list(qubits)

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # If qubits = [], just reset qubits
        if qubits:

            # Check that there are no repeated qubits
            if len(qubits) != len(set(qubits)):
                raise ValueError(f&#34;Repeated qubits are not allowed.&#34;)

            # Check that it matches the correct number
            if self.name != &#39;MATRIX&#39; and _available_gates[
                    self.name][&#39;n_qubits&#39;] != len(qubits):
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_qubits&#39;]} qubits.&#34;
                )
            elif self.name == &#39;MATRIX&#39;:
                if len(self.U) != 2**len(qubits):
                    raise ValueError(
                        f&#34;Gate(name=&#39;{self.name}&#39;) requires {int(np.log2(len(self.U)))} qubits.&#34;
                    )

            # Assign qubits
            object.__setattr__(_g, &#39;qubits&#39;, qubits)

        elif hasattr(self, &#39;qubits&#39;):

            # Remove qubits
            object.__delattr__(_g, &#39;qubits&#39;)

        return _g

    def _set_params(self, params: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Set `params` to `Gate`.
        &#34;&#34;&#34;

        self.set_params(params, inplace=True)

    def set_params(self, params: iter[any], *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with given `params`. If `inplace` is `True`, `Gate` is
        modified in place.

        Parameters
        ----------
        params: iter[any]
            Parameters used to define the new Gate.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with `params`. If `inplace` is `True`, `Gate` is modified
            in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;RX&#39;)
        Gate(name=RX)
        &gt;&gt;&gt; Gate(&#39;RX&#39;).unitary()
        ValueError: Gate(name=&#39;RX&#39;) requires 1 parameters.
        &gt;&gt;&gt; Gate(&#39;H&#39;).set_params([1.23]).unitary()
        array([[0.81677345+0.j        , 0.        -0.57695852j],
               [0.        -0.57695852j, 0.81677345+0.j        ]])
        &#34;&#34;&#34;

        # Convert params to list
        if params is not None:
            params = list(params)

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # If params = [], just reset params
        if params:

            # Check that it matches the correct number
            if self.name != &#39;MATRIX&#39; and _available_gates[
                    self.name][&#39;n_params&#39;] != len(params):
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_params&#39;]} parameters.&#34;
                )
            elif self.name == &#39;MATRIX&#39;:
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) does not accept parameters.&#34;)

            # Assign params
            object.__setattr__(_g, &#39;params&#39;, params)

        elif hasattr(self, &#39;params&#39;):

            # Remove params
            object.__delattr__(_g, &#39;params&#39;)

        return _g

    def _set_tags(self, tags: dict[any, any]) -&gt; None:
        &#34;&#34;&#34;
        Set `tags` to `Gate`.
        &#34;&#34;&#34;

        self.set_tags(tags, inplace=True)

    def set_tags(self, tags: dict[any, any], *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with given `tags`. All previous tags are removed and
        substituted with `tags`. If `inplace` is `True`, `Gate` is modified in
        place.

        Parameters
        ----------
        tags: dict[any, any]
            Parameters used to define the new `Gate`.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with `tags`. If `inplace` is `True`, `Gate` is modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;)
        Gate(name=T)
        &gt;&gt;&gt; Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23}).set_tags({42: 42})
        Gate(name=T, tags={42: 42})
        &#34;&#34;&#34;

        # Convert tags to dict
        if tags is not None:
            tags = {**tags}

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # If tags = {}, just reset tags
        if tags:

            # Assign tags
            object.__setattr__(_g, &#39;tags&#39;, tags)

        elif hasattr(self, &#39;tags&#39;):

            # Remove params
            object.__delattr__(_g, &#39;tags&#39;)

        return _g

    def _update_tags(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Update `Gate`&#39;s `tags`.
        &#34;&#34;&#34;

        self.update_tags(*args, **kwargs, inplace=True)

    def update_tags(self, *args, inplace: bool = False, **kwargs) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with updated tags. If `inplace` is `True`, `Gate` is
        modified in place.

        Parameters
        ----------
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with updated tags. If `inplace` is `True`, `Gate` is
            modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;)
        Gate(name=T)
        &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g
        Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g.update_tags({1: 3})
        Gate(name=T, tags={1: 3, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g.update_tags([(1, -1), (42, 42)])
        Gate(name=T, tags={1: -1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23, 42: 42})
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        if not hasattr(_g, &#39;tags&#39;):
            object.__setattr__(_g, &#39;tags&#39;, dict())

        # Update tags
        _g.tags.update(*args, **kwargs)

        return _g

    def _remove_tags(self, keys: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Remove tags matching `keys`.
        &#34;&#34;&#34;

        self.remove_tags(keys, inplace=True)

    def remove_tags(self, keys: iter[any], *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with removed tags matching `keys`. If `inplace` is `True`,
        `Gate` is modified in place.

        Parameters
        ----------
        keys: iter[any]
            Keys to remove from tags.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with `keys` in tags removed. If `inplace` is `True`,
            `Gate` is modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;)
        Gate(name=T)
        &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g
        Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g.remove_tags((&#39;2&#39;, (1, 2)))
        Gate(name=T, tags={&#39;2&#39;: &#39;2&#39;})
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        if hasattr(_g, &#39;tags&#39;):

            # Convert to set
            keys = set(keys)

            # Remove tags
            _g._set_tags({k: v for k, v in _g.tags.items() if k not in keys})

        return _g

    def _remove_tag(self, key: any) -&gt; None:
        &#34;&#34;&#34;
        Remove tag matching `key`.
        &#34;&#34;&#34;

        self.remove_tag(key, inplace=True)

    def remove_tag(self, key: any, *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with removed tag mathcing `key`. If `inplace` is `True`,
        `Gate` is modified in place.

        Parameters
        ----------
        key: any
            Key to remove from tags.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with `key` in tags removed. If `inplace` is `True`,
            `Gate` is modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;)
        Gate(name=T)
        &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g
        Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g.remove_tag(&#39;2&#39;)
        Gate(name=T, tags={1: 1, (1, 2): 2.23})
        &#34;&#34;&#34;

        return self.remove_tags([key], inplace=inplace)

    def _set_power(self, power: any) -&gt; None:
        &#34;&#34;&#34;
        Set `power` to `Gate`.
        &#34;&#34;&#34;

        self.set_power(power, inplace=True)

    def set_power(self, power: any, *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` to the given `power`. If `inplace` is `True`, `Gate` is
        modified in place.

        Parameters
        ----------
        power: any
            Power to elevate `Gate`.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` to the given `power`. If `inplace` is `True`, `Gate` is
            modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;).unitary()
        array([[1.        +0.j        , 0.        +0.j        ],
               [0.        +0.j        , 0.70710678+0.70710678j]])
        &gt;&gt;&gt; Gate(&#39;T&#39;).set_power(3.1416).unitary()
        array([[ 1.        +0.j        ,  0.        +0.j        ],
               [ 0.        +0.j        , -0.78121549+0.62426145j]])
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # Assign qubits
        object.__setattr__(_g, &#39;power&#39;, power)

        return _g

    def unitary(self, order: iter[any] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Return unitary matrix representing `Gate`. If `order` is provided, the
        given order of qubits is used to output the unitary matrix.

        Parameters
        ----------
        order: iter[any]
            Order of qubits used to output the unitary matrix.

        Returns
        -------
        array_like
            Unitary matrix representing `Gate`.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;CX&#39;, qubits=[1, 0]).unitary()
        array([[1, 0, 0, 0],
               [0, 1, 0, 0],
               [0, 0, 0, 1],
               [0, 0, 1, 0]])

        The order of qubits is `[1, 0]`. On the contrary:
        &gt;&gt;&gt; Gate(&#39;CX&#39;, qubits=[1, 0]).unitary(order=[0, 1])
        array([[1, 0, 0, 0],
               [0, 0, 0, 1],
               [0, 0, 1, 0],
               [0, 1, 0, 0]])

        outputs a unitary matrix with the qubits order being if `[0, 1]`.
        &#34;&#34;&#34;

        # Check if params are missing
        if self.name in _available_gates and _available_gates[
                self.name][&#39;n_params&#39;]:
            if not hasattr(self, &#39;params&#39;) or len(
                    self.params) != _available_gates[self.name][&#39;n_params&#39;]:
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_params&#39;]} parameters.&#34;
                )

        # Covert order to list
        if order is not None:
            order = list(order)

        # Order is allowed only if gate.qubits are specified
        if order and (not hasattr(self, &#39;qubits&#39;) or
                      sort(order) != sort(self.qubits)):
            raise ValueError(&#34;&#39;order&#39; is not a permutation of &#39;gate.qubits&#39;.&#34;)

        # Check if the unitary generator is available
        if self.name in _available_gates and &#39;U_gen&#39; in _available_gates[
                self.name]:
            _U = _available_gates[self.name][&#39;U_gen&#39;](
                *([float(p)
                   for p in self.params] if hasattr(self, &#39;params&#39;) else []))
        elif self.name == &#39;MATRIX&#39;:
            _U = self.U
        else:
            raise ValueError(f&#34;Not supported for Gate(name=&#39;{self.name}&#39;)&#34;)

        # Reorder matrix in case qubits are out-of-order
        if order and order != self.qubits:
            # Get number of qubits
            n_qubits = len(self.qubits)
            # Transpose
            _U = np.reshape(
                np.transpose(np.reshape(_U, (2,) * (2 * n_qubits)),
                             [self.qubits.index(q) for q in order] +
                             [n_qubits + self.qubits.index(q) for q in order]),
                (2**n_qubits, 2**n_qubits))

        # Apply power
        if self.power == 1:
            pass
        elif self.power == -1:
            _U = _U.T.conj()
        else:
            _U = fractional_matrix_power(_U, float(self.power))

        return _U

    def commutes_with(self, gate: Gate, atol: float = 1e-8) -&gt; bool:
        &#34;&#34;&#34;
        Return `True` if the calling gate commutes with `gate`.

        Parameters
        ----------
        gate: Gate
            Gate to check commutation with.
        atol: float
            Absolute tollerance.

        Returns
        -------
        bool
            `True` if the calling gate commutes with `gate`, otherwise `False`.
        &#34;&#34;&#34;

        # Get shared qubits
        shared_qubits = sort(set(self.qubits).intersection(gate.qubits))

        # If no qubits are shared, the gates definitely commute
        if not shared_qubits:
            return True

        # Get decompositions
        _, U1, _ = svd(self.unitary(),
                       [self.qubits.index(q) for q in shared_qubits],
                       atol=atol)
        _, U2, _ = svd(gate.unitary(),
                       [gate.qubits.index(q) for q in shared_qubits],
                       atol=atol)

        return np.allclose([a @ b - b @ a for a in U1 for b in U2],
                           0,
                           atol=atol)

    def isvirtual(self) -&gt; bool:
        &#34;&#34;&#34;
        Return `True` if `Gate` is virtual and `False` otherwise. `Gate` is virtual if
        at least one of the following statement is true:

        - `Gate` is not applied to any qubits,
        - `Gate`&#39;s parameters are not specified (if required) or not convertible
          to `float`,
        - `Gate`&#39;s power is not convertible to `float`.

        Returns
        -------
        bool
            `True` if `Gate` is virtual, `False` otherwise.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;RX&#39;).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1]).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[lambda x: x**2]).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[3.2]).isvirtual()
        False

        If only the qubits are not specified, it is still possible to get the
        unitary matrix representing `Gate`, even if `Gate` is virtual:
        &gt;&gt;&gt; Gate(&#39;RX&#39;).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;).unitary()
        ValueError: Gate(name=&#39;RX&#39;) requires 1 parameters.
        &gt;&gt;&gt; Gate(&#39;RX&#39;, params=[3.2]).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, params=[3.2]).unitary()
        array([[-0.02919952-0.j       ,  0.        -0.9995736j],
               [ 0.        -0.9995736j, -0.02919952-0.j       ]])
        &#34;&#34;&#34;

        # Check if qubits have been assigned. If not, gate is virtual
        if not hasattr(self, &#39;qubits&#39;):
            return True

        # Check if power is convertible to float. If not, gate is virtual
        try:
            float(self.power)
        except:
            return True

        # If gate.name != &#39;MATRIX&#39;, check if all parameters are convertible to float.
        # If not, gate is virtual
        if self.name != &#39;MATRIX&#39; and _available_gates[
                self.name][&#39;n_params&#39;] != 0:
            if hasattr(self, &#39;params&#39;):
                try:
                    [float(p) for p in self.params]
                except:
                    return True
            else:
                return True

        return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hybridq.gate.Gate"><code class="flex name class">
<span>class <span class="ident">Gate</span></span>
<span>(</span><span>name: str, qubits: iter[any] = None, params: iter[any] = None, power: any = 1, tags: dict[any, any] = None, U: list[list[any]] = None, check_unitary: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a single gate.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>.</dd>
<dt><strong><code>qubits</code></strong> :&ensp;<code>list[any]</code>, optional</dt>
<dd>List of qubits <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is acting on.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>list[any]</code>, optional</dt>
<dd>List of parameters to define <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The power the unitary matrix of <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is elevated to.</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>dict[any, any]</code>, optional</dt>
<dd>Dictionary of tags.</dd>
<dt><strong><code>U</code></strong> :&ensp;<code>list[list[any]]</code>, optional</dt>
<dd>If <code>name</code> is <code>MATRIX</code>, its unitary matrix must be provided using <code>U</code>.</dd>
<dt><strong><code>check_unitary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>U</code> is provided, check that <code>U</code> is unitary. Otherwise, raise
<code>ValueError</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; g = Gate('RX', qubits=[1], params=[3.2])**3.4
&gt;&gt;&gt; g.unitary()
array([[6.65087527e-01+1.10596489e-16j, 6.50125829e-17+7.46765413e-01j],
       [9.71433860e-18+7.46765413e-01j, 6.65087527e-01+1.05739319e-16j]])
</code></pre>
<p>It is also possible to specify gates by using their matrix representation:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; g = Gate('MATRIX', qubits=[1], U=[[0,-1j], [1j, 0]])
&gt;&gt;&gt; g
Gate(name=MATRIX, qubits=[1], U=np.array(shape=(2, 2), dtype=complex128))
&gt;&gt;&gt; g.isclose(Gate('Y')) # Acting on different qubits
False
&gt;&gt;&gt; g.isclose(Gate('Y', qubits=[1])) # Acting on the same qubits
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gate(object):
    &#34;&#34;&#34;
    Class representing a single gate.

    Attributes
    ----------
    name: str
        Name of `Gate`.
    qubits: list[any], optional
        List of qubits `Gate` is acting on.
    params: list[any], optional
        List of parameters to define `Gate`.
    power: float, optional
        The power the unitary matrix of `Gate` is elevated to.
    tags: dict[any, any], optional
        Dictionary of tags.
    U: list[list[any]], optional
        If `name` is `MATRIX`, its unitary matrix must be provided using `U`.
    check_unitary: bool, optional
        If `U` is provided, check that `U` is unitary. Otherwise, raise
        `ValueError`.

    Example
    -------
    &gt;&gt;&gt; g = Gate(&#39;RX&#39;, qubits=[1], params=[3.2])**3.4
    &gt;&gt;&gt; g.unitary()
    array([[6.65087527e-01+1.10596489e-16j, 6.50125829e-17+7.46765413e-01j],
           [9.71433860e-18+7.46765413e-01j, 6.65087527e-01+1.05739319e-16j]])

    It is also possible to specify gates by using their matrix representation:
    &gt;&gt;&gt; g = Gate(&#39;MATRIX&#39;, qubits=[1], U=[[0,-1j], [1j, 0]])
    &gt;&gt;&gt; g
    Gate(name=MATRIX, qubits=[1], U=np.array(shape=(2, 2), dtype=complex128))
    &gt;&gt;&gt; g.isclose(Gate(&#39;Y&#39;)) # Acting on different qubits
    False
    &gt;&gt;&gt; g.isclose(Gate(&#39;Y&#39;, qubits=[1])) # Acting on the same qubits
    True
    &#34;&#34;&#34;

    def __setattr__(self, *args) -&gt; None:
        raise ValueError(&#34;Operation not permitted.&#34;)

    def __delattr__(self, *args) -&gt; None:
        raise ValueError(&#34;Operation not permitted.&#34;)

    def __init__(self,
                 name: str,
                 qubits: iter[any] = None,
                 params: iter[any] = None,
                 power: any = 1,
                 tags: dict[any, any] = None,
                 U: list[list[any]] = None,
                 check_unitary: bool = False) -&gt; None:

        # Convert name to upper
        name = name.upper()

        # Check if name is an alias
        if name in _gate_aliases:
            warn(
                f&#34;&#39;{name}&#39; is an alias for &#39;{_gate_aliases[name]}&#39;. Using Gate(name=&#39;{_gate_aliases[name]}&#39;).&#34;
            )
            name = _gate_aliases[name]

        # Check if name is in _available_qubits
        if name not in _available_gates and name != &#39;MATRIX&#39;:
            raise ValueError(f&#34;Gate(name=&#39;{name}&#39;) not available.&#34;)

        # If MATRIX, the unitary matrix must be provided
        if name == &#39;MATRIX&#39;:
            # Check that matrix representation is present
            if U is None:
                raise ValueError(&#34;Gate(name=&#39;MATRIX&#39;) requires &#39;U&#39;.&#34;)

            # Assign U ..
            object.__setattr__(self, &#39;U&#39;, np.array(U))

            # .. and make it read-only
            self.U.flags[&#39;WRITEABLE&#39;] = False

            # Check shape
            _x, _y = self.U.shape
            if _x != _y or not np.isclose(np.log2(_x), int(np.log2(_x))):
                raise ValueError(
                    f&#34;&#39;U&#39; must be a quadratic matrix of shape (2^n, 2^n).&#34;)

            # Check if unitary
            if check_unitary:
                if not np.allclose(self.U.dot(self.U.T.conj()),
                                   np.eye(len(self.U))) or not np.allclose(
                                       np.eye(len(self.U)),
                                       self.U.dot(self.U.T.conj())):
                    raise ValueError(f&#34;&#39;U&#39; must be a unitary matrix.&#34;)

        # Set gate
        object.__setattr__(self, &#39;name&#39;, str(name))

        # Update qubits
        self._on(qubits)

        # Update params
        self._set_params(params)

        # Set power
        self._set_power(power)

        # Update tags
        self._set_tags(tags)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Return string representation of Gate.
        &#34;&#34;&#34;

        _str = f&#34;Gate(name=&#39;{self.name}&#39;&#34;
        if hasattr(self, &#39;qubits&#39;):
            _str += f&#34;, qubits={self.qubits}&#34;
        if hasattr(self, &#39;params&#39;) and len(self.params):
            _str += f&#34;, params={self.params}&#34;
        if self.name == &#39;MATRIX&#39;:
            _str += f&#39;, U=np.array(shape={self.U.shape}, dtype={str(self.U.dtype)})&#39;
        if hasattr(self, &#39;tags&#39;) and self.tags:
            _str += f&#39;, tags={self.tags}&#39;
        _str += &#39;)&#39;
        if self.power != 1:
            _str += f&#39;**{self.power}&#39;
        return _str

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Return string representation of Gate.
        &#34;&#34;&#34;

        return self.__str__()

    def __neq__(self, g: Gate) -&gt; bool:
        return not (self.__eq__(g))

    def __eq__(self, g: Gate) -&gt; bool:
        &#34;&#34;&#34;
        Two gates are equal if everything matches (including tags).
        &#34;&#34;&#34;

        # If keys don&#39;t match, the gates differ
        if self.__dict__.keys() != g.__dict__.keys():

            return False

        else:

            # Check key by key
            for k, v in self.__dict__.items():

                # If np.ndarray, return False if at least one element differs
                if type(v) == np.ndarray:
                    if np.any(v != g.__dict__[k]):
                        return False

                # Otherwise, return False if the two values are not equivalent
                else:
                    if v != g.__dict__[k]:
                        return False

            return True

    def isclose(self, gate: Gate, atol: float = 1e-8) -&gt; bool:
        &#34;&#34;&#34;
        Determine if the unitary matrix of `gate` is close within an absolute
        tollerance. If the gates are acting on a different set of qubits,
        `isclose` will return `False`.

        Parameters
        ----------
        gate: Gate
            Gate to compare with.
        atol: float, optional
            Absolute tollerance.

        Returns
        -------
        bool
            `True` if the two gates are close withing the given absolute
            tollerance, otherwise `False`.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;X&#39;, qubits=[1]).isclose(Gate(&#39;Y&#39;, qubits=[1]))
        False
        &gt;&gt;&gt; Gate(&#39;Y&#39;, qubits=[1]).isclose(Gate(&#39;Y&#39;, qubits=[2]))
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1]).isclose(Gate(&#39;RX&#39;, qubits=[1]))
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[1.23]).isclose(Gate(&#39;RX&#39;, qubits=[1]))
        False
        &#34;&#34;&#34;

        if hasattr(self, &#39;qubits&#39;) == hasattr(gate, &#39;qubits&#39;):

            # The gates differ if they act on a different set of qubits
            if hasattr(self,
                       &#39;qubits&#39;) and sort(self.qubits) != sort(gate.qubits):
                return False

            # If the gates have the same name, we can avoid to create unitaries if there is a match
            if self.name == gate.name and self.name != &#39;MATRIX&#39; and np.isclose(
                    float(self.power), float(gate.power), atol=atol):
                if not hasattr(self, &#39;qubits&#39;) or self.qubits == gate.qubits:
                    if hasattr(self, &#39;params&#39;) == hasattr(gate, &#39;params&#39;):
                        if not hasattr(self, &#39;params&#39;) or np.allclose(
                            [float(p) for p in self.params],
                            [float(p) for p in gate.params],
                                atol=atol):
                            return True

            # Get unitaries
            _U1 = self.unitary() if self.name == &#39;MATRIX&#39; or _available_gates[
                self.name][&#39;n_params&#39;] == 0 or hasattr(self, &#39;params&#39;) else None
            _U2 = gate.unitary(
                order=self.qubits if hasattr(self, &#39;qubits&#39;) else None
            ) if gate.name == &#39;MATRIX&#39; or _available_gates[
                gate.name][&#39;n_params&#39;] == 0 or hasattr(gate, &#39;params&#39;) else None

            # If either unitary does not exist, the two gates differ
            if _U1 is None or _U2 is None:
                return False
            else:
                return np.allclose(_U1, _U2, atol=atol)

        else:

            return False

    def __pow__(self, p: any) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate`**p.
        &#34;&#34;&#34;

        return self.set_power(self.power * p, inplace=False)

    def _inv(self) -&gt; None:
        &#34;&#34;&#34;
        Modify `Gate` to its inverse.
        &#34;&#34;&#34;

        self.inv(inplace=True)

    def inv(self, *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return inverse of `Gate`. If `inplace` is `True`, `Gate` is modified in place.

        Parameters
        ----------
        inplace: bool, optional
            If `True`, Gate is modified in place. Otherwise, a new
            `Gate` is returned.

        Returns
        -------
        Gate
            Inverse of `Gate`. If `True`, `Gate` is modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;P&#39;)
        Gate(name=P)
        &gt;&gt;&gt; Gate(&#39;P&#39;).inv()
        Gate(name=P)**-1
        &gt;&gt;&gt; Gate(&#39;P&#39;).unitary().dot(Gate(&#39;P&#39;).inv().unitary())
        array([[1.+0.j, 0.+0.j],
               [0.+0.j, 1.+0.j]])
        &#34;&#34;&#34;

        return self.set_power(self.power * -1, inplace=inplace)

    def _on(self, qubits: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Set `qubits` to `Gate`.
        &#34;&#34;&#34;

        self.on(qubits, inplace=True)

    def on(self, qubits: iter[any], *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` applied to `qubits`. If `inplace` is `True`, `Gate` is
        modified in place.

        Parameters
        ----------
        qubits: iter[any]
            Qubits the new Gate will act on.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate`
            is returned.

        Returns
        -------
        Gate
            New `Gate` acting on `qubits`. If `inplace` is `True`, `Gate` is
            modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;H&#39;)
        Gate(name=H)
        &gt;&gt;&gt; Gate(&#39;H&#39;).on([3])
        Gate(name=H, qubits=[3])
        &#34;&#34;&#34;

        # Convert qubits to list
        if qubits is not None:
            qubits = list(qubits)

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # If qubits = [], just reset qubits
        if qubits:

            # Check that there are no repeated qubits
            if len(qubits) != len(set(qubits)):
                raise ValueError(f&#34;Repeated qubits are not allowed.&#34;)

            # Check that it matches the correct number
            if self.name != &#39;MATRIX&#39; and _available_gates[
                    self.name][&#39;n_qubits&#39;] != len(qubits):
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_qubits&#39;]} qubits.&#34;
                )
            elif self.name == &#39;MATRIX&#39;:
                if len(self.U) != 2**len(qubits):
                    raise ValueError(
                        f&#34;Gate(name=&#39;{self.name}&#39;) requires {int(np.log2(len(self.U)))} qubits.&#34;
                    )

            # Assign qubits
            object.__setattr__(_g, &#39;qubits&#39;, qubits)

        elif hasattr(self, &#39;qubits&#39;):

            # Remove qubits
            object.__delattr__(_g, &#39;qubits&#39;)

        return _g

    def _set_params(self, params: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Set `params` to `Gate`.
        &#34;&#34;&#34;

        self.set_params(params, inplace=True)

    def set_params(self, params: iter[any], *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with given `params`. If `inplace` is `True`, `Gate` is
        modified in place.

        Parameters
        ----------
        params: iter[any]
            Parameters used to define the new Gate.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with `params`. If `inplace` is `True`, `Gate` is modified
            in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;RX&#39;)
        Gate(name=RX)
        &gt;&gt;&gt; Gate(&#39;RX&#39;).unitary()
        ValueError: Gate(name=&#39;RX&#39;) requires 1 parameters.
        &gt;&gt;&gt; Gate(&#39;H&#39;).set_params([1.23]).unitary()
        array([[0.81677345+0.j        , 0.        -0.57695852j],
               [0.        -0.57695852j, 0.81677345+0.j        ]])
        &#34;&#34;&#34;

        # Convert params to list
        if params is not None:
            params = list(params)

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # If params = [], just reset params
        if params:

            # Check that it matches the correct number
            if self.name != &#39;MATRIX&#39; and _available_gates[
                    self.name][&#39;n_params&#39;] != len(params):
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_params&#39;]} parameters.&#34;
                )
            elif self.name == &#39;MATRIX&#39;:
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) does not accept parameters.&#34;)

            # Assign params
            object.__setattr__(_g, &#39;params&#39;, params)

        elif hasattr(self, &#39;params&#39;):

            # Remove params
            object.__delattr__(_g, &#39;params&#39;)

        return _g

    def _set_tags(self, tags: dict[any, any]) -&gt; None:
        &#34;&#34;&#34;
        Set `tags` to `Gate`.
        &#34;&#34;&#34;

        self.set_tags(tags, inplace=True)

    def set_tags(self, tags: dict[any, any], *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with given `tags`. All previous tags are removed and
        substituted with `tags`. If `inplace` is `True`, `Gate` is modified in
        place.

        Parameters
        ----------
        tags: dict[any, any]
            Parameters used to define the new `Gate`.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with `tags`. If `inplace` is `True`, `Gate` is modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;)
        Gate(name=T)
        &gt;&gt;&gt; Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23}).set_tags({42: 42})
        Gate(name=T, tags={42: 42})
        &#34;&#34;&#34;

        # Convert tags to dict
        if tags is not None:
            tags = {**tags}

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # If tags = {}, just reset tags
        if tags:

            # Assign tags
            object.__setattr__(_g, &#39;tags&#39;, tags)

        elif hasattr(self, &#39;tags&#39;):

            # Remove params
            object.__delattr__(_g, &#39;tags&#39;)

        return _g

    def _update_tags(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Update `Gate`&#39;s `tags`.
        &#34;&#34;&#34;

        self.update_tags(*args, **kwargs, inplace=True)

    def update_tags(self, *args, inplace: bool = False, **kwargs) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with updated tags. If `inplace` is `True`, `Gate` is
        modified in place.

        Parameters
        ----------
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with updated tags. If `inplace` is `True`, `Gate` is
            modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;)
        Gate(name=T)
        &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g
        Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g.update_tags({1: 3})
        Gate(name=T, tags={1: 3, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g.update_tags([(1, -1), (42, 42)])
        Gate(name=T, tags={1: -1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23, 42: 42})
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        if not hasattr(_g, &#39;tags&#39;):
            object.__setattr__(_g, &#39;tags&#39;, dict())

        # Update tags
        _g.tags.update(*args, **kwargs)

        return _g

    def _remove_tags(self, keys: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Remove tags matching `keys`.
        &#34;&#34;&#34;

        self.remove_tags(keys, inplace=True)

    def remove_tags(self, keys: iter[any], *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with removed tags matching `keys`. If `inplace` is `True`,
        `Gate` is modified in place.

        Parameters
        ----------
        keys: iter[any]
            Keys to remove from tags.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with `keys` in tags removed. If `inplace` is `True`,
            `Gate` is modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;)
        Gate(name=T)
        &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g
        Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g.remove_tags((&#39;2&#39;, (1, 2)))
        Gate(name=T, tags={&#39;2&#39;: &#39;2&#39;})
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        if hasattr(_g, &#39;tags&#39;):

            # Convert to set
            keys = set(keys)

            # Remove tags
            _g._set_tags({k: v for k, v in _g.tags.items() if k not in keys})

        return _g

    def _remove_tag(self, key: any) -&gt; None:
        &#34;&#34;&#34;
        Remove tag matching `key`.
        &#34;&#34;&#34;

        self.remove_tag(key, inplace=True)

    def remove_tag(self, key: any, *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` with removed tag mathcing `key`. If `inplace` is `True`,
        `Gate` is modified in place.

        Parameters
        ----------
        key: any
            Key to remove from tags.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` with `key` in tags removed. If `inplace` is `True`,
            `Gate` is modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;)
        Gate(name=T)
        &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g
        Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
        &gt;&gt;&gt; g.remove_tag(&#39;2&#39;)
        Gate(name=T, tags={1: 1, (1, 2): 2.23})
        &#34;&#34;&#34;

        return self.remove_tags([key], inplace=inplace)

    def _set_power(self, power: any) -&gt; None:
        &#34;&#34;&#34;
        Set `power` to `Gate`.
        &#34;&#34;&#34;

        self.set_power(power, inplace=True)

    def set_power(self, power: any, *, inplace: bool = False) -&gt; Gate:
        &#34;&#34;&#34;
        Return `Gate` to the given `power`. If `inplace` is `True`, `Gate` is
        modified in place.

        Parameters
        ----------
        power: any
            Power to elevate `Gate`.
        inplace: bool, optional
            If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
            returned.

        Returns
        -------
        Gate
            New `Gate` to the given `power`. If `inplace` is `True`, `Gate` is
            modified in place.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;T&#39;).unitary()
        array([[1.        +0.j        , 0.        +0.j        ],
               [0.        +0.j        , 0.70710678+0.70710678j]])
        &gt;&gt;&gt; Gate(&#39;T&#39;).set_power(3.1416).unitary()
        array([[ 1.        +0.j        ,  0.        +0.j        ],
               [ 0.        +0.j        , -0.78121549+0.62426145j]])
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # Assign qubits
        object.__setattr__(_g, &#39;power&#39;, power)

        return _g

    def unitary(self, order: iter[any] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Return unitary matrix representing `Gate`. If `order` is provided, the
        given order of qubits is used to output the unitary matrix.

        Parameters
        ----------
        order: iter[any]
            Order of qubits used to output the unitary matrix.

        Returns
        -------
        array_like
            Unitary matrix representing `Gate`.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;CX&#39;, qubits=[1, 0]).unitary()
        array([[1, 0, 0, 0],
               [0, 1, 0, 0],
               [0, 0, 0, 1],
               [0, 0, 1, 0]])

        The order of qubits is `[1, 0]`. On the contrary:
        &gt;&gt;&gt; Gate(&#39;CX&#39;, qubits=[1, 0]).unitary(order=[0, 1])
        array([[1, 0, 0, 0],
               [0, 0, 0, 1],
               [0, 0, 1, 0],
               [0, 1, 0, 0]])

        outputs a unitary matrix with the qubits order being if `[0, 1]`.
        &#34;&#34;&#34;

        # Check if params are missing
        if self.name in _available_gates and _available_gates[
                self.name][&#39;n_params&#39;]:
            if not hasattr(self, &#39;params&#39;) or len(
                    self.params) != _available_gates[self.name][&#39;n_params&#39;]:
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_params&#39;]} parameters.&#34;
                )

        # Covert order to list
        if order is not None:
            order = list(order)

        # Order is allowed only if gate.qubits are specified
        if order and (not hasattr(self, &#39;qubits&#39;) or
                      sort(order) != sort(self.qubits)):
            raise ValueError(&#34;&#39;order&#39; is not a permutation of &#39;gate.qubits&#39;.&#34;)

        # Check if the unitary generator is available
        if self.name in _available_gates and &#39;U_gen&#39; in _available_gates[
                self.name]:
            _U = _available_gates[self.name][&#39;U_gen&#39;](
                *([float(p)
                   for p in self.params] if hasattr(self, &#39;params&#39;) else []))
        elif self.name == &#39;MATRIX&#39;:
            _U = self.U
        else:
            raise ValueError(f&#34;Not supported for Gate(name=&#39;{self.name}&#39;)&#34;)

        # Reorder matrix in case qubits are out-of-order
        if order and order != self.qubits:
            # Get number of qubits
            n_qubits = len(self.qubits)
            # Transpose
            _U = np.reshape(
                np.transpose(np.reshape(_U, (2,) * (2 * n_qubits)),
                             [self.qubits.index(q) for q in order] +
                             [n_qubits + self.qubits.index(q) for q in order]),
                (2**n_qubits, 2**n_qubits))

        # Apply power
        if self.power == 1:
            pass
        elif self.power == -1:
            _U = _U.T.conj()
        else:
            _U = fractional_matrix_power(_U, float(self.power))

        return _U

    def commutes_with(self, gate: Gate, atol: float = 1e-8) -&gt; bool:
        &#34;&#34;&#34;
        Return `True` if the calling gate commutes with `gate`.

        Parameters
        ----------
        gate: Gate
            Gate to check commutation with.
        atol: float
            Absolute tollerance.

        Returns
        -------
        bool
            `True` if the calling gate commutes with `gate`, otherwise `False`.
        &#34;&#34;&#34;

        # Get shared qubits
        shared_qubits = sort(set(self.qubits).intersection(gate.qubits))

        # If no qubits are shared, the gates definitely commute
        if not shared_qubits:
            return True

        # Get decompositions
        _, U1, _ = svd(self.unitary(),
                       [self.qubits.index(q) for q in shared_qubits],
                       atol=atol)
        _, U2, _ = svd(gate.unitary(),
                       [gate.qubits.index(q) for q in shared_qubits],
                       atol=atol)

        return np.allclose([a @ b - b @ a for a in U1 for b in U2],
                           0,
                           atol=atol)

    def isvirtual(self) -&gt; bool:
        &#34;&#34;&#34;
        Return `True` if `Gate` is virtual and `False` otherwise. `Gate` is virtual if
        at least one of the following statement is true:

        - `Gate` is not applied to any qubits,
        - `Gate`&#39;s parameters are not specified (if required) or not convertible
          to `float`,
        - `Gate`&#39;s power is not convertible to `float`.

        Returns
        -------
        bool
            `True` if `Gate` is virtual, `False` otherwise.

        Example
        -------
        &gt;&gt;&gt; Gate(&#39;RX&#39;).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1]).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[lambda x: x**2]).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[3.2]).isvirtual()
        False

        If only the qubits are not specified, it is still possible to get the
        unitary matrix representing `Gate`, even if `Gate` is virtual:
        &gt;&gt;&gt; Gate(&#39;RX&#39;).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;).unitary()
        ValueError: Gate(name=&#39;RX&#39;) requires 1 parameters.
        &gt;&gt;&gt; Gate(&#39;RX&#39;, params=[3.2]).isvirtual()
        True
        &gt;&gt;&gt; Gate(&#39;RX&#39;, params=[3.2]).unitary()
        array([[-0.02919952-0.j       ,  0.        -0.9995736j],
               [ 0.        -0.9995736j, -0.02919952-0.j       ]])
        &#34;&#34;&#34;

        # Check if qubits have been assigned. If not, gate is virtual
        if not hasattr(self, &#39;qubits&#39;):
            return True

        # Check if power is convertible to float. If not, gate is virtual
        try:
            float(self.power)
        except:
            return True

        # If gate.name != &#39;MATRIX&#39;, check if all parameters are convertible to float.
        # If not, gate is virtual
        if self.name != &#39;MATRIX&#39; and _available_gates[
                self.name][&#39;n_params&#39;] != 0:
            if hasattr(self, &#39;params&#39;):
                try:
                    [float(p) for p in self.params]
                except:
                    return True
            else:
                return True

        return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="hybridq.gate.Gate.commutes_with"><code class="name flex">
<span>def <span class="ident">commutes_with</span></span>(<span>self, gate: <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a>, atol: float = 1e-08) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if the calling gate commutes with <code>gate</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gate</code></strong> :&ensp;<code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>Gate to check commutation with.</dd>
<dt><strong><code>atol</code></strong> :&ensp;<code>float</code></dt>
<dd>Absolute tollerance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the calling gate commutes with <code>gate</code>, otherwise <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commutes_with(self, gate: Gate, atol: float = 1e-8) -&gt; bool:
    &#34;&#34;&#34;
    Return `True` if the calling gate commutes with `gate`.

    Parameters
    ----------
    gate: Gate
        Gate to check commutation with.
    atol: float
        Absolute tollerance.

    Returns
    -------
    bool
        `True` if the calling gate commutes with `gate`, otherwise `False`.
    &#34;&#34;&#34;

    # Get shared qubits
    shared_qubits = sort(set(self.qubits).intersection(gate.qubits))

    # If no qubits are shared, the gates definitely commute
    if not shared_qubits:
        return True

    # Get decompositions
    _, U1, _ = svd(self.unitary(),
                   [self.qubits.index(q) for q in shared_qubits],
                   atol=atol)
    _, U2, _ = svd(gate.unitary(),
                   [gate.qubits.index(q) for q in shared_qubits],
                   atol=atol)

    return np.allclose([a @ b - b @ a for a in U1 for b in U2],
                       0,
                       atol=atol)</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.inv"><code class="name flex">
<span>def <span class="ident">inv</span></span>(<span>self, *, inplace: bool = False) ‑> <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return inverse of <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, Gate is modified in place. Otherwise, a new
<code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>Inverse of <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>. If <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('P')
Gate(name=P)
&gt;&gt;&gt; Gate('P').inv()
Gate(name=P)**-1
&gt;&gt;&gt; Gate('P').unitary().dot(Gate('P').inv().unitary())
array([[1.+0.j, 0.+0.j],
       [0.+0.j, 1.+0.j]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inv(self, *, inplace: bool = False) -&gt; Gate:
    &#34;&#34;&#34;
    Return inverse of `Gate`. If `inplace` is `True`, `Gate` is modified in place.

    Parameters
    ----------
    inplace: bool, optional
        If `True`, Gate is modified in place. Otherwise, a new
        `Gate` is returned.

    Returns
    -------
    Gate
        Inverse of `Gate`. If `True`, `Gate` is modified in place.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;P&#39;)
    Gate(name=P)
    &gt;&gt;&gt; Gate(&#39;P&#39;).inv()
    Gate(name=P)**-1
    &gt;&gt;&gt; Gate(&#39;P&#39;).unitary().dot(Gate(&#39;P&#39;).inv().unitary())
    array([[1.+0.j, 0.+0.j],
           [0.+0.j, 1.+0.j]])
    &#34;&#34;&#34;

    return self.set_power(self.power * -1, inplace=inplace)</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.isclose"><code class="name flex">
<span>def <span class="ident">isclose</span></span>(<span>self, gate: <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a>, atol: float = 1e-08) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if the unitary matrix of <code>gate</code> is close within an absolute
tollerance. If the gates are acting on a different set of qubits,
<code>isclose</code> will return <code>False</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gate</code></strong> :&ensp;<code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>Gate to compare with.</dd>
<dt><strong><code>atol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Absolute tollerance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the two gates are close withing the given absolute
tollerance, otherwise <code>False</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('X', qubits=[1]).isclose(Gate('Y', qubits=[1]))
False
&gt;&gt;&gt; Gate('Y', qubits=[1]).isclose(Gate('Y', qubits=[2]))
True
&gt;&gt;&gt; Gate('RX', qubits=[1]).isclose(Gate('RX', qubits=[1]))
True
&gt;&gt;&gt; Gate('RX', qubits=[1], params=[1.23]).isclose(Gate('RX', qubits=[1]))
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isclose(self, gate: Gate, atol: float = 1e-8) -&gt; bool:
    &#34;&#34;&#34;
    Determine if the unitary matrix of `gate` is close within an absolute
    tollerance. If the gates are acting on a different set of qubits,
    `isclose` will return `False`.

    Parameters
    ----------
    gate: Gate
        Gate to compare with.
    atol: float, optional
        Absolute tollerance.

    Returns
    -------
    bool
        `True` if the two gates are close withing the given absolute
        tollerance, otherwise `False`.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;X&#39;, qubits=[1]).isclose(Gate(&#39;Y&#39;, qubits=[1]))
    False
    &gt;&gt;&gt; Gate(&#39;Y&#39;, qubits=[1]).isclose(Gate(&#39;Y&#39;, qubits=[2]))
    True
    &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1]).isclose(Gate(&#39;RX&#39;, qubits=[1]))
    True
    &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[1.23]).isclose(Gate(&#39;RX&#39;, qubits=[1]))
    False
    &#34;&#34;&#34;

    if hasattr(self, &#39;qubits&#39;) == hasattr(gate, &#39;qubits&#39;):

        # The gates differ if they act on a different set of qubits
        if hasattr(self,
                   &#39;qubits&#39;) and sort(self.qubits) != sort(gate.qubits):
            return False

        # If the gates have the same name, we can avoid to create unitaries if there is a match
        if self.name == gate.name and self.name != &#39;MATRIX&#39; and np.isclose(
                float(self.power), float(gate.power), atol=atol):
            if not hasattr(self, &#39;qubits&#39;) or self.qubits == gate.qubits:
                if hasattr(self, &#39;params&#39;) == hasattr(gate, &#39;params&#39;):
                    if not hasattr(self, &#39;params&#39;) or np.allclose(
                        [float(p) for p in self.params],
                        [float(p) for p in gate.params],
                            atol=atol):
                        return True

        # Get unitaries
        _U1 = self.unitary() if self.name == &#39;MATRIX&#39; or _available_gates[
            self.name][&#39;n_params&#39;] == 0 or hasattr(self, &#39;params&#39;) else None
        _U2 = gate.unitary(
            order=self.qubits if hasattr(self, &#39;qubits&#39;) else None
        ) if gate.name == &#39;MATRIX&#39; or _available_gates[
            gate.name][&#39;n_params&#39;] == 0 or hasattr(gate, &#39;params&#39;) else None

        # If either unitary does not exist, the two gates differ
        if _U1 is None or _U2 is None:
            return False
        else:
            return np.allclose(_U1, _U2, atol=atol)

    else:

        return False</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.isvirtual"><code class="name flex">
<span>def <span class="ident">isvirtual</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is virtual and <code>False</code> otherwise. <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is virtual if
at least one of the following statement is true:</p>
<ul>
<li><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is not applied to any qubits,</li>
<li><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>'s parameters are not specified (if required) or not convertible
to <code>float</code>,</li>
<li><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>'s power is not convertible to <code>float</code>.</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is virtual, <code>False</code> otherwise.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('RX').isvirtual()
True
&gt;&gt;&gt; Gate('RX', qubits=[1]).isvirtual()
True
&gt;&gt;&gt; Gate('RX', qubits=[1], params=[lambda x: x**2]).isvirtual()
True
&gt;&gt;&gt; Gate('RX', qubits=[1], params=[3.2]).isvirtual()
False
</code></pre>
<p>If only the qubits are not specified, it is still possible to get the
unitary matrix representing <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>, even if <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is virtual:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('RX').isvirtual()
True
&gt;&gt;&gt; Gate('RX').unitary()
ValueError: Gate(name='RX') requires 1 parameters.
&gt;&gt;&gt; Gate('RX', params=[3.2]).isvirtual()
True
&gt;&gt;&gt; Gate('RX', params=[3.2]).unitary()
array([[-0.02919952-0.j       ,  0.        -0.9995736j],
       [ 0.        -0.9995736j, -0.02919952-0.j       ]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isvirtual(self) -&gt; bool:
    &#34;&#34;&#34;
    Return `True` if `Gate` is virtual and `False` otherwise. `Gate` is virtual if
    at least one of the following statement is true:

    - `Gate` is not applied to any qubits,
    - `Gate`&#39;s parameters are not specified (if required) or not convertible
      to `float`,
    - `Gate`&#39;s power is not convertible to `float`.

    Returns
    -------
    bool
        `True` if `Gate` is virtual, `False` otherwise.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;RX&#39;).isvirtual()
    True
    &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1]).isvirtual()
    True
    &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[lambda x: x**2]).isvirtual()
    True
    &gt;&gt;&gt; Gate(&#39;RX&#39;, qubits=[1], params=[3.2]).isvirtual()
    False

    If only the qubits are not specified, it is still possible to get the
    unitary matrix representing `Gate`, even if `Gate` is virtual:
    &gt;&gt;&gt; Gate(&#39;RX&#39;).isvirtual()
    True
    &gt;&gt;&gt; Gate(&#39;RX&#39;).unitary()
    ValueError: Gate(name=&#39;RX&#39;) requires 1 parameters.
    &gt;&gt;&gt; Gate(&#39;RX&#39;, params=[3.2]).isvirtual()
    True
    &gt;&gt;&gt; Gate(&#39;RX&#39;, params=[3.2]).unitary()
    array([[-0.02919952-0.j       ,  0.        -0.9995736j],
           [ 0.        -0.9995736j, -0.02919952-0.j       ]])
    &#34;&#34;&#34;

    # Check if qubits have been assigned. If not, gate is virtual
    if not hasattr(self, &#39;qubits&#39;):
        return True

    # Check if power is convertible to float. If not, gate is virtual
    try:
        float(self.power)
    except:
        return True

    # If gate.name != &#39;MATRIX&#39;, check if all parameters are convertible to float.
    # If not, gate is virtual
    if self.name != &#39;MATRIX&#39; and _available_gates[
            self.name][&#39;n_params&#39;] != 0:
        if hasattr(self, &#39;params&#39;):
            try:
                [float(p) for p in self.params]
            except:
                return True
        else:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.on"><code class="name flex">
<span>def <span class="ident">on</span></span>(<span>self, qubits: iter[any], *, inplace: bool = False) ‑> <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> applied to <code>qubits</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>qubits</code></strong> :&ensp;<code>iter[any]</code></dt>
<dd>Qubits the new Gate will act on.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place. Otherwise, a new <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>
is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>New <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> acting on <code>qubits</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
modified in place.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('H')
Gate(name=H)
&gt;&gt;&gt; Gate('H').on([3])
Gate(name=H, qubits=[3])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on(self, qubits: iter[any], *, inplace: bool = False) -&gt; Gate:
    &#34;&#34;&#34;
    Return `Gate` applied to `qubits`. If `inplace` is `True`, `Gate` is
    modified in place.

    Parameters
    ----------
    qubits: iter[any]
        Qubits the new Gate will act on.
    inplace: bool, optional
        If `True`, `Gate` is modified in place. Otherwise, a new `Gate`
        is returned.

    Returns
    -------
    Gate
        New `Gate` acting on `qubits`. If `inplace` is `True`, `Gate` is
        modified in place.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;H&#39;)
    Gate(name=H)
    &gt;&gt;&gt; Gate(&#39;H&#39;).on([3])
    Gate(name=H, qubits=[3])
    &#34;&#34;&#34;

    # Convert qubits to list
    if qubits is not None:
        qubits = list(qubits)

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    # If qubits = [], just reset qubits
    if qubits:

        # Check that there are no repeated qubits
        if len(qubits) != len(set(qubits)):
            raise ValueError(f&#34;Repeated qubits are not allowed.&#34;)

        # Check that it matches the correct number
        if self.name != &#39;MATRIX&#39; and _available_gates[
                self.name][&#39;n_qubits&#39;] != len(qubits):
            raise ValueError(
                f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_qubits&#39;]} qubits.&#34;
            )
        elif self.name == &#39;MATRIX&#39;:
            if len(self.U) != 2**len(qubits):
                raise ValueError(
                    f&#34;Gate(name=&#39;{self.name}&#39;) requires {int(np.log2(len(self.U)))} qubits.&#34;
                )

        # Assign qubits
        object.__setattr__(_g, &#39;qubits&#39;, qubits)

    elif hasattr(self, &#39;qubits&#39;):

        # Remove qubits
        object.__delattr__(_g, &#39;qubits&#39;)

    return _g</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.remove_tag"><code class="name flex">
<span>def <span class="ident">remove_tag</span></span>(<span>self, key: any, *, inplace: bool = False) ‑> <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with removed tag mathcing <code>key</code>. If <code>inplace</code> is <code>True</code>,
<code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>any</code></dt>
<dd>Key to remove from tags.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place. Otherwise, a new <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>New <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with <code>key</code> in tags removed. If <code>inplace</code> is <code>True</code>,
<code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('T')
Gate(name=T)
&gt;&gt;&gt; g = Gate('T').set_tags({1: 1, '2': '2', (1, 2): 2.23})
&gt;&gt;&gt; g
Gate(name=T, tags={1: 1, '2': '2', (1, 2): 2.23})
&gt;&gt;&gt; g.remove_tag('2')
Gate(name=T, tags={1: 1, (1, 2): 2.23})
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_tag(self, key: any, *, inplace: bool = False) -&gt; Gate:
    &#34;&#34;&#34;
    Return `Gate` with removed tag mathcing `key`. If `inplace` is `True`,
    `Gate` is modified in place.

    Parameters
    ----------
    key: any
        Key to remove from tags.
    inplace: bool, optional
        If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
        returned.

    Returns
    -------
    Gate
        New `Gate` with `key` in tags removed. If `inplace` is `True`,
        `Gate` is modified in place.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;T&#39;)
    Gate(name=T)
    &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    &gt;&gt;&gt; g
    Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    &gt;&gt;&gt; g.remove_tag(&#39;2&#39;)
    Gate(name=T, tags={1: 1, (1, 2): 2.23})
    &#34;&#34;&#34;

    return self.remove_tags([key], inplace=inplace)</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.remove_tags"><code class="name flex">
<span>def <span class="ident">remove_tags</span></span>(<span>self, keys: iter[any], *, inplace: bool = False) ‑> <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with removed tags matching <code>keys</code>. If <code>inplace</code> is <code>True</code>,
<code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>keys</code></strong> :&ensp;<code>iter[any]</code></dt>
<dd>Keys to remove from tags.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place. Otherwise, a new <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>New <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with <code>keys</code> in tags removed. If <code>inplace</code> is <code>True</code>,
<code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('T')
Gate(name=T)
&gt;&gt;&gt; g = Gate('T').set_tags({1: 1, '2': '2', (1, 2): 2.23})
&gt;&gt;&gt; g
Gate(name=T, tags={1: 1, '2': '2', (1, 2): 2.23})
&gt;&gt;&gt; g.remove_tags(('2', (1, 2)))
Gate(name=T, tags={'2': '2'})
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_tags(self, keys: iter[any], *, inplace: bool = False) -&gt; Gate:
    &#34;&#34;&#34;
    Return `Gate` with removed tags matching `keys`. If `inplace` is `True`,
    `Gate` is modified in place.

    Parameters
    ----------
    keys: iter[any]
        Keys to remove from tags.
    inplace: bool, optional
        If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
        returned.

    Returns
    -------
    Gate
        New `Gate` with `keys` in tags removed. If `inplace` is `True`,
        `Gate` is modified in place.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;T&#39;)
    Gate(name=T)
    &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    &gt;&gt;&gt; g
    Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    &gt;&gt;&gt; g.remove_tags((&#39;2&#39;, (1, 2)))
    Gate(name=T, tags={&#39;2&#39;: &#39;2&#39;})
    &#34;&#34;&#34;

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    if hasattr(_g, &#39;tags&#39;):

        # Convert to set
        keys = set(keys)

        # Remove tags
        _g._set_tags({k: v for k, v in _g.tags.items() if k not in keys})

    return _g</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.set_params"><code class="name flex">
<span>def <span class="ident">set_params</span></span>(<span>self, params: iter[any], *, inplace: bool = False) ‑> <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with given <code>params</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>iter[any]</code></dt>
<dd>Parameters used to define the new Gate.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place. Otherwise, a new <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>New <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with <code>params</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified
in place.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('RX')
Gate(name=RX)
&gt;&gt;&gt; Gate('RX').unitary()
ValueError: Gate(name='RX') requires 1 parameters.
&gt;&gt;&gt; Gate('H').set_params([1.23]).unitary()
array([[0.81677345+0.j        , 0.        -0.57695852j],
       [0.        -0.57695852j, 0.81677345+0.j        ]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_params(self, params: iter[any], *, inplace: bool = False) -&gt; Gate:
    &#34;&#34;&#34;
    Return `Gate` with given `params`. If `inplace` is `True`, `Gate` is
    modified in place.

    Parameters
    ----------
    params: iter[any]
        Parameters used to define the new Gate.
    inplace: bool, optional
        If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
        returned.

    Returns
    -------
    Gate
        New `Gate` with `params`. If `inplace` is `True`, `Gate` is modified
        in place.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;RX&#39;)
    Gate(name=RX)
    &gt;&gt;&gt; Gate(&#39;RX&#39;).unitary()
    ValueError: Gate(name=&#39;RX&#39;) requires 1 parameters.
    &gt;&gt;&gt; Gate(&#39;H&#39;).set_params([1.23]).unitary()
    array([[0.81677345+0.j        , 0.        -0.57695852j],
           [0.        -0.57695852j, 0.81677345+0.j        ]])
    &#34;&#34;&#34;

    # Convert params to list
    if params is not None:
        params = list(params)

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    # If params = [], just reset params
    if params:

        # Check that it matches the correct number
        if self.name != &#39;MATRIX&#39; and _available_gates[
                self.name][&#39;n_params&#39;] != len(params):
            raise ValueError(
                f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_params&#39;]} parameters.&#34;
            )
        elif self.name == &#39;MATRIX&#39;:
            raise ValueError(
                f&#34;Gate(name=&#39;{self.name}&#39;) does not accept parameters.&#34;)

        # Assign params
        object.__setattr__(_g, &#39;params&#39;, params)

    elif hasattr(self, &#39;params&#39;):

        # Remove params
        object.__delattr__(_g, &#39;params&#39;)

    return _g</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.set_power"><code class="name flex">
<span>def <span class="ident">set_power</span></span>(<span>self, power: any, *, inplace: bool = False) ‑> <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> to the given <code>power</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>power</code></strong> :&ensp;<code>any</code></dt>
<dd>Power to elevate <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place. Otherwise, a new <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>New <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> to the given <code>power</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
modified in place.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('T').unitary()
array([[1.        +0.j        , 0.        +0.j        ],
       [0.        +0.j        , 0.70710678+0.70710678j]])
&gt;&gt;&gt; Gate('T').set_power(3.1416).unitary()
array([[ 1.        +0.j        ,  0.        +0.j        ],
       [ 0.        +0.j        , -0.78121549+0.62426145j]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_power(self, power: any, *, inplace: bool = False) -&gt; Gate:
    &#34;&#34;&#34;
    Return `Gate` to the given `power`. If `inplace` is `True`, `Gate` is
    modified in place.

    Parameters
    ----------
    power: any
        Power to elevate `Gate`.
    inplace: bool, optional
        If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
        returned.

    Returns
    -------
    Gate
        New `Gate` to the given `power`. If `inplace` is `True`, `Gate` is
        modified in place.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;T&#39;).unitary()
    array([[1.        +0.j        , 0.        +0.j        ],
           [0.        +0.j        , 0.70710678+0.70710678j]])
    &gt;&gt;&gt; Gate(&#39;T&#39;).set_power(3.1416).unitary()
    array([[ 1.        +0.j        ,  0.        +0.j        ],
           [ 0.        +0.j        , -0.78121549+0.62426145j]])
    &#34;&#34;&#34;

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    # Assign qubits
    object.__setattr__(_g, &#39;power&#39;, power)

    return _g</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.set_tags"><code class="name flex">
<span>def <span class="ident">set_tags</span></span>(<span>self, tags: dict[any, any], *, inplace: bool = False) ‑> <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with given <code>tags</code>. All previous tags are removed and
substituted with <code>tags</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in
place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>dict[any, any]</code></dt>
<dd>Parameters used to define the new <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place. Otherwise, a new <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>New <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with <code>tags</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('T')
Gate(name=T)
&gt;&gt;&gt; Gate('T').set_tags({1: 1, '2': '2', (1, 2): 2.23})
Gate(name=T, tags={1: 1, '2': '2', (1, 2): 2.23})
&gt;&gt;&gt; Gate('T').set_tags({1: 1, '2': '2', (1, 2): 2.23}).set_tags({42: 42})
Gate(name=T, tags={42: 42})
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tags(self, tags: dict[any, any], *, inplace: bool = False) -&gt; Gate:
    &#34;&#34;&#34;
    Return `Gate` with given `tags`. All previous tags are removed and
    substituted with `tags`. If `inplace` is `True`, `Gate` is modified in
    place.

    Parameters
    ----------
    tags: dict[any, any]
        Parameters used to define the new `Gate`.
    inplace: bool, optional
        If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
        returned.

    Returns
    -------
    Gate
        New `Gate` with `tags`. If `inplace` is `True`, `Gate` is modified in place.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;T&#39;)
    Gate(name=T)
    &gt;&gt;&gt; Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    &gt;&gt;&gt; Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23}).set_tags({42: 42})
    Gate(name=T, tags={42: 42})
    &#34;&#34;&#34;

    # Convert tags to dict
    if tags is not None:
        tags = {**tags}

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    # If tags = {}, just reset tags
    if tags:

        # Assign tags
        object.__setattr__(_g, &#39;tags&#39;, tags)

    elif hasattr(self, &#39;tags&#39;):

        # Remove params
        object.__delattr__(_g, &#39;tags&#39;)

    return _g</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.unitary"><code class="name flex">
<span>def <span class="ident">unitary</span></span>(<span>self, order: iter[any] = None) ‑> np.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return unitary matrix representing <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>. If <code>order</code> is provided, the
given order of qubits is used to output the unitary matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>iter[any]</code></dt>
<dd>Order of qubits used to output the unitary matrix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array_like</code></dt>
<dd>Unitary matrix representing <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code>.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('CX', qubits=[1, 0]).unitary()
array([[1, 0, 0, 0],
       [0, 1, 0, 0],
       [0, 0, 0, 1],
       [0, 0, 1, 0]])
</code></pre>
<p>The order of qubits is <code>[1, 0]</code>. On the contrary:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('CX', qubits=[1, 0]).unitary(order=[0, 1])
array([[1, 0, 0, 0],
       [0, 0, 0, 1],
       [0, 0, 1, 0],
       [0, 1, 0, 0]])
</code></pre>
<p>outputs a unitary matrix with the qubits order being if <code>[0, 1]</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unitary(self, order: iter[any] = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Return unitary matrix representing `Gate`. If `order` is provided, the
    given order of qubits is used to output the unitary matrix.

    Parameters
    ----------
    order: iter[any]
        Order of qubits used to output the unitary matrix.

    Returns
    -------
    array_like
        Unitary matrix representing `Gate`.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;CX&#39;, qubits=[1, 0]).unitary()
    array([[1, 0, 0, 0],
           [0, 1, 0, 0],
           [0, 0, 0, 1],
           [0, 0, 1, 0]])

    The order of qubits is `[1, 0]`. On the contrary:
    &gt;&gt;&gt; Gate(&#39;CX&#39;, qubits=[1, 0]).unitary(order=[0, 1])
    array([[1, 0, 0, 0],
           [0, 0, 0, 1],
           [0, 0, 1, 0],
           [0, 1, 0, 0]])

    outputs a unitary matrix with the qubits order being if `[0, 1]`.
    &#34;&#34;&#34;

    # Check if params are missing
    if self.name in _available_gates and _available_gates[
            self.name][&#39;n_params&#39;]:
        if not hasattr(self, &#39;params&#39;) or len(
                self.params) != _available_gates[self.name][&#39;n_params&#39;]:
            raise ValueError(
                f&#34;Gate(name=&#39;{self.name}&#39;) requires {_available_gates[self.name][&#39;n_params&#39;]} parameters.&#34;
            )

    # Covert order to list
    if order is not None:
        order = list(order)

    # Order is allowed only if gate.qubits are specified
    if order and (not hasattr(self, &#39;qubits&#39;) or
                  sort(order) != sort(self.qubits)):
        raise ValueError(&#34;&#39;order&#39; is not a permutation of &#39;gate.qubits&#39;.&#34;)

    # Check if the unitary generator is available
    if self.name in _available_gates and &#39;U_gen&#39; in _available_gates[
            self.name]:
        _U = _available_gates[self.name][&#39;U_gen&#39;](
            *([float(p)
               for p in self.params] if hasattr(self, &#39;params&#39;) else []))
    elif self.name == &#39;MATRIX&#39;:
        _U = self.U
    else:
        raise ValueError(f&#34;Not supported for Gate(name=&#39;{self.name}&#39;)&#34;)

    # Reorder matrix in case qubits are out-of-order
    if order and order != self.qubits:
        # Get number of qubits
        n_qubits = len(self.qubits)
        # Transpose
        _U = np.reshape(
            np.transpose(np.reshape(_U, (2,) * (2 * n_qubits)),
                         [self.qubits.index(q) for q in order] +
                         [n_qubits + self.qubits.index(q) for q in order]),
            (2**n_qubits, 2**n_qubits))

    # Apply power
    if self.power == 1:
        pass
    elif self.power == -1:
        _U = _U.T.conj()
    else:
        _U = fractional_matrix_power(_U, float(self.power))

    return _U</code></pre>
</details>
</dd>
<dt id="hybridq.gate.Gate.update_tags"><code class="name flex">
<span>def <span class="ident">update_tags</span></span>(<span>self, *args, inplace: bool = False, **kwargs) ‑> <a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with updated tags. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is modified in place. Otherwise, a new <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></dt>
<dd>New <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> with updated tags. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code> is
modified in place.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Gate('T')
Gate(name=T)
&gt;&gt;&gt; g = Gate('T').set_tags({1: 1, '2': '2', (1, 2): 2.23})
&gt;&gt;&gt; g
Gate(name=T, tags={1: 1, '2': '2', (1, 2): 2.23})
&gt;&gt;&gt; g.update_tags({1: 3})
Gate(name=T, tags={1: 3, '2': '2', (1, 2): 2.23})
&gt;&gt;&gt; g.update_tags([(1, -1), (42, 42)])
Gate(name=T, tags={1: -1, '2': '2', (1, 2): 2.23, 42: 42})
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tags(self, *args, inplace: bool = False, **kwargs) -&gt; Gate:
    &#34;&#34;&#34;
    Return `Gate` with updated tags. If `inplace` is `True`, `Gate` is
    modified in place.

    Parameters
    ----------
    inplace: bool, optional
        If `True`, `Gate` is modified in place. Otherwise, a new `Gate` is
        returned.

    Returns
    -------
    Gate
        New `Gate` with updated tags. If `inplace` is `True`, `Gate` is
        modified in place.

    Example
    -------
    &gt;&gt;&gt; Gate(&#39;T&#39;)
    Gate(name=T)
    &gt;&gt;&gt; g = Gate(&#39;T&#39;).set_tags({1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    &gt;&gt;&gt; g
    Gate(name=T, tags={1: 1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    &gt;&gt;&gt; g.update_tags({1: 3})
    Gate(name=T, tags={1: 3, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23})
    &gt;&gt;&gt; g.update_tags([(1, -1), (42, 42)])
    Gate(name=T, tags={1: -1, &#39;2&#39;: &#39;2&#39;, (1, 2): 2.23, 42: 42})
    &#34;&#34;&#34;

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    if not hasattr(_g, &#39;tags&#39;):
        object.__setattr__(_g, &#39;tags&#39;, dict())

    # Update tags
    _g.tags.update(*args, **kwargs)

    return _g</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq" href="index.html">hybridq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hybridq.gate.Gate" href="#hybridq.gate.Gate">Gate</a></code></h4>
<ul class="two-column">
<li><code><a title="hybridq.gate.Gate.commutes_with" href="#hybridq.gate.Gate.commutes_with">commutes_with</a></code></li>
<li><code><a title="hybridq.gate.Gate.inv" href="#hybridq.gate.Gate.inv">inv</a></code></li>
<li><code><a title="hybridq.gate.Gate.isclose" href="#hybridq.gate.Gate.isclose">isclose</a></code></li>
<li><code><a title="hybridq.gate.Gate.isvirtual" href="#hybridq.gate.Gate.isvirtual">isvirtual</a></code></li>
<li><code><a title="hybridq.gate.Gate.on" href="#hybridq.gate.Gate.on">on</a></code></li>
<li><code><a title="hybridq.gate.Gate.remove_tag" href="#hybridq.gate.Gate.remove_tag">remove_tag</a></code></li>
<li><code><a title="hybridq.gate.Gate.remove_tags" href="#hybridq.gate.Gate.remove_tags">remove_tags</a></code></li>
<li><code><a title="hybridq.gate.Gate.set_params" href="#hybridq.gate.Gate.set_params">set_params</a></code></li>
<li><code><a title="hybridq.gate.Gate.set_power" href="#hybridq.gate.Gate.set_power">set_power</a></code></li>
<li><code><a title="hybridq.gate.Gate.set_tags" href="#hybridq.gate.Gate.set_tags">set_tags</a></code></li>
<li><code><a title="hybridq.gate.Gate.unitary" href="#hybridq.gate.Gate.unitary">unitary</a></code></li>
<li><code><a title="hybridq.gate.Gate.update_tags" href="#hybridq.gate.Gate.update_tags">update_tags</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>