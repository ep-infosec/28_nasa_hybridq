<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hybridq.base.property API documentation</title>
<meta name="description" content="Author: Salvatore Mandra (salvatore.mandra@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.base.property</code></h1>
</header>
<section id="section-intro">
<p>Author: Salvatore Mandra (salvatore.mandra@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Salvatore Mandra (salvatore.mandra@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
from hybridq.base import __Base__, generate
from hybridq.base import staticvars, compare, requires
from hybridq.utils import isintegral, isnumber
from copy import copy, deepcopy


@staticvars(&#39;docstring&#39;,
            docstring=&#34;&#34;,
            transform=dict(docstring=lambda x: str(x)))
class DocString(__Base__):
    &#34;&#34;&#34;
    Add docstring to an object.
    &#34;&#34;&#34;

    def __init_subclass__(cls, **kwargs):
        # Call super
        super().__init_subclass__(**kwargs)

        # Update docstring
        cls.__doc__ = cls.__get_staticvar__(&#39;docstring&#39;)


class Tags(__Base__):
    &#34;&#34;&#34;
    Add tags to a object.

    Attributes
    ----------
    tags: dict[any, any], optional
        Dictionary of tags.
    &#34;&#34;&#34;

    def __init__(self, tags: dict[any, any] = None, **kwargs) -&gt; None:
        # Call super
        super().__init__(**kwargs)

        # Set tags
        self.__tags = {} if tags is None else dict(tags)

    def __print__(self) -&gt; dict[str, tuple[int, str, int]]:
        return {&#39;tags&#39;: (999, f&#39;tags={self.tags}&#39; if self.tags else &#39;&#39;, 0)}

    @property
    def tags(self) -&gt; dict[any, any]:
        return self.__tags

    def _set_tags(self, tags: dict[any, any]) -&gt; None:
        &#34;&#34;&#34;
        Set `tags` to `Tags`.
        &#34;&#34;&#34;

        self.set_tags(tags, inplace=True)

    def set_tags(self,
                 tags: dict[any, any] = None,
                 *,
                 inplace: bool = False) -&gt; Tags:
        &#34;&#34;&#34;
        Return `Tags` with given `tags`. All previous tags are removed and
        substituted with `tags`. If `inplace` is `True`, `Tags` is modified
        in place.

        Parameters
        ----------
        tags: dict[any, any]
            Parameters used to define the new `Tags`.
        inplace: bool, optional
            If `True`, `Tags` is modified in place. Otherwise, a new
            `Tags` is returned.

        Returns
        -------
        Tags
            New `Tags` with `tags`. If `inplace` is `True`, `Tags` is
            modified in place.
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # If tags is not None, set tags
        if tags is not None:

            # Assign tags
            _g.__tags = dict(tags)

        # Otherwise, remove tags
        else:

            # Clear tags
            _g.__tags.clear()

        return _g

    def _update_tags(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Update `Tags`&#39;s `tags`.
        &#34;&#34;&#34;

        self.update_tags(*args, **kwargs, inplace=True)

    def update_tags(self, *args, inplace: bool = False, **kwargs) -&gt; Tags:
        &#34;&#34;&#34;
        Return `Tags` with updated tags. If `inplace` is `True`, `Tags` is
        modified in place.

        Parameters
        ----------
        inplace: bool, optional
            If `True`, `Tags` is modified in place. Otherwise, a new `Tags` is
            returned.

        Returns
        -------
        Tags
            New `Tags` with updated tags. If `inplace` is `True`, `Tags` is
            modified in place.
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # Update tags
        _g.tags.update(*args, **kwargs)

        return _g

    def _remove_tags(self, keys: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Remove tags matching `keys`.
        &#34;&#34;&#34;

        self.remove_tags(keys, inplace=True)

    def remove_tags(self, keys: iter[any], *, inplace: bool = False) -&gt; Tags:
        &#34;&#34;&#34;
        Return `Tags` with removed tags matching `keys`. If `inplace` is
        `True`, `Tags` is modified in place.

        Parameters
        ----------
        keys: iter[any]
            Keys to remove from tags.
        inplace: bool, optional
            If `True`, `Tags` is modified in place. Otherwise, a new
            `Tags` is returned.

        Returns
        -------
        Tags
            New `Tags` with `keys` in tags removed. If `inplace` is `True`,
            `Tags` is modified in place.
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # Convert to set
        keys = set(keys)

        # Remove tags
        _g._set_tags({k: v for k, v in _g.tags.items() if k not in keys})

        return _g

    def _remove_tag(self, key: any) -&gt; None:
        &#34;&#34;&#34;
        Remove tag matching `key`.
        &#34;&#34;&#34;

        self.remove_tag(key, inplace=True)

    def remove_tag(self, key: any, *, inplace: bool = False) -&gt; Tags:
        &#34;&#34;&#34;
        Return `Tags` with removed tag mathcing `key`. If `inplace` is
        `True`, `Tags` is modified in place.

        Parameters
        ----------
        key: any
            Key to remove from tags.
        inplace: bool, optional
            If `True`, `Tags` is modified in place. Otherwise, a new
            `Tags` is returned.

        Returns
        -------
        Tags
            New `Tags` with `key` in tags removed. If `inplace` is `True`,
            `Tags` is modified in place.
        &#34;&#34;&#34;

        return self.remove_tags([key], inplace=inplace)


@compare(&#39;name&#39;)
@staticvars(&#39;name&#39;,
            check=dict(name=(lambda s: isinstance(s, str),
                             &#34;&#39;name&#39; must be &#39;str&#39;&#34;)))
class Name(__Base__):
    &#34;&#34;&#34;
    Add name to a object.
    &#34;&#34;&#34;

    def __print__(self) -&gt; dict[str, tuple[int, str, int]]:
        return {
            &#39;name&#39;: (0, f&#34;name=&#39;{self.name}&#39;&#34; if self.name else &#39;&#39;, 0),
        }


@compare(&#39;n_params,params&#39;)
@staticvars(
    &#39;n_params&#39;,
    check=dict(n_params=(lambda n: n is any or (isintegral(n) and n &gt;= 0),
                         &#34;&#39;n_params&#39; must be a non-negative integer&#34;)))
class Params(__Base__):
    &#34;&#34;&#34;
    Add parameters to class.

    Attributes
    ----------
    params: iter[any], optional
    &#34;&#34;&#34;

    def __init__(self, params: iter[any] = None, **kwargs) -&gt; None:
        # Call super
        super().__init__(**kwargs)

        # Set params
        self._set_params(params)

    @property
    def params(self) -&gt; tuple[any]:
        return self.__params

    def __print__(self) -&gt; dict[str, tuple[int, str, int]]:
        return {
            &#39;n_params&#39;:
                (11, f&#34;n_params={self.n_params}&#34; if self.params is None else &#39;&#39;,
                 0),
            &#39;params&#39;: (101, f&#34;params={self.params}&#34; if self.params else &#34;&#34;, 0),
        }

    def _set_params(self, params: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Set `params` to `Params`.
        &#34;&#34;&#34;

        self.set_params(params, inplace=True)

    def set_params(self, params: iter[any], *, inplace: bool = False) -&gt; Params:
        &#34;&#34;&#34;
        Return `Params` with given `params`. If `inplace` is `True`,
        `Params` is modified in place.

        Parameters
        ----------
        params: iter[any]
            Parameters used to define the new Params.
        inplace: bool, optional
            If `True`, `Params` is modified in place. Otherwise, a new
            `Params` is returned.

        Returns
        -------
        Params
            New `Params` with `params`. If `inplace` is `True`, `Params`
            is modified in place.
        &#34;&#34;&#34;

        # Set default
        if params is None and self.n_params == 0:
            params = tuple()

        # Check params is tuple convertible
        if params is not None:
            try:
                params = tuple(params)
            except:
                raise ValueError(&#34;&#39;params&#39; must be &#39;tuple&#39; convertible.&#34;)

        # Check lenght
        if params is not None and len(params) != self.n_params:
            raise ValueError(f&#34;Wrong number of &#39;params&#39; &#34;
                             f&#34;(expected {self.n_params}, got {len(params)})&#34;)

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # Set
        _g.__params = params

        # Return
        return _g


@compare(&#39;elements&#39;)
@staticvars(&#39;_base_check&#39;,
            _base_check=None,
            check=dict(_base_check=lambda ts: ts is None or all(
                callable(k) and all(type(t) == type for t in ts) for k, ts in ts
                .items())),
            transform=dict(_base_check=lambda ts: None if ts is None else dict(
                (k, tuple(ts)) for k, ts in dict(ts).items())))
class Tuple(Tags, __Base__):
    &#34;&#34;&#34;
    Tuple class for `__Base__`.
    &#34;&#34;&#34;

    def __init__(self, elements=tuple(), tags=None, **kwargs):
        # Call super
        super().__init__(tags=tags, **kwargs)

        # Convert elements to tuple
        elements = tuple(elements)

        # Check that all elements are __Base__
        if not all(isinstance(el, __Base__) for el in elements):
            raise TypeError(f&#34;Only &#39;__Base__&#39; elements are supported&#34;)

        # Get possible basis
        _base_check = self.__get_staticvar__(&#39;_base_check&#39;)

        if _base_check and not all(
                f(isinstance(el, t)
                  for t in ts)
                for el in elements
                for f, ts in _base_check.items()):
            raise TypeError(
                f&#34;Only {self.__get_staticvar__(&#39;_base_check&#39;)} elements are supported&#34;
            )

        # Initialize elements
        self.__elements = elements

    @property
    def elements(self):
        return self.__elements

    def __len__(self) -&gt; int:
        return len(self.elements)

    def __print__(self) -&gt; dict[str, tuple[int, str, int]]:
        # Get string representation
        _el = &#39;, &#39;.join(str(e) for e in self.elements)

        # Return representation
        return dict(elements=(0, _el if len(self) else &#39;&#39;, 0))

    def __getitem__(self, *args, **kwargs):
        # Get elements
        return self.elements.__getitem__(*args, **kwargs)

    def index(self, *args, **kwargs):
        # Get index
        return self.elements.index(*args, **kwargs)

    def __radd__(self, other: Tuple):
        # If &#39;other&#39; is &#39;tuple&#39; try to convert ..
        if isinstance(other, tuple):
            # .. to type(self) or ..
            try:
                other = type(self)(other)

            # .. to Tuple.
            except:
                other = Tuple(other)

        # Check that other is a Tuple
        if not isinstance(other, Tuple):
            raise TypeError(f&#34;Type &#39;{type(other).__name__}&#39; not supported&#34;)

        # Return Tuple. If self and other have different types, fallback to Type.
        return (type(self) if type(self) == type(other) else
                Tuple)(other.elements + self.elements)

    def __add__(self, other: Tuple) -&gt; Tuple:
        # If &#39;other&#39; is &#39;tuple&#39; try to convert ..
        if isinstance(other, tuple):
            # .. to type(self) or ..
            try:
                other = type(self)(other)

            # .. to Tuple.
            except:
                other = Tuple(other)

        # &#39;other&#39; must be Tuple
        if not isinstance(other, Tuple):
            raise TypeError(f&#34;Type &#39;{type(other).__name__}&#39; not supported&#34;)

        # Get left and right tags
        l_tags = self.tags if self.provides(&#39;tags&#39;) else {}
        r_tags = other.tags if other.provides(&#39;tags&#39;) else {}

        # Get common keys
        ckeys = set(l_tags).intersection(r_tags)

        # Create new tags
        tags = {}
        tags.update({
            (str(k) + &#39;_x&#39; if k in ckeys else k): v for k, v in l_tags.items()
        })
        tags.update({
            (str(k) + &#39;_y&#39; if k in ckeys else k): v for k, v in r_tags.items()
        })

        # If self and other have different types, fallback to Tuple
        other = (type(self) if type(self) == type(other) else
                 Tuple)(self.elements + other.elements)

        # Update tags and return
        return other.update_tags(tags, inplace=True)

    def flatten(self) -&gt; Tuple:
        &#34;&#34;&#34;
        Return a flattend `Tuple`.
        &#34;&#34;&#34;
        return type(self)(y for x in (g.flatten(
        ) if isinstance(g, Tuple) and g.provides(&#39;flatten&#39;) else [g]
                                      for g in self) for y in x)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hybridq.base.property.DocString"><code class="flex name class">
<span>class <span class="ident">DocString</span></span>
</code></dt>
<dd>
<div class="desc"><p>Add docstring to an object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DocString(__Base__):
    &#34;&#34;&#34;
    Add docstring to an object.
    &#34;&#34;&#34;

    def __init_subclass__(cls, **kwargs):
        # Call super
        super().__init_subclass__(**kwargs)

        # Update docstring
        cls.__doc__ = cls.__get_staticvar__(&#39;docstring&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>hybridq.base.base.__Base__</li>
</ul>
</dd>
<dt id="hybridq.base.property.Name"><code class="flex name class">
<span>class <span class="ident">Name</span></span>
</code></dt>
<dd>
<div class="desc"><p>Add name to a object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Name(__Base__):
    &#34;&#34;&#34;
    Add name to a object.
    &#34;&#34;&#34;

    def __print__(self) -&gt; dict[str, tuple[int, str, int]]:
        return {
            &#39;name&#39;: (0, f&#34;name=&#39;{self.name}&#39;&#34; if self.name else &#39;&#39;, 0),
        }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>hybridq.base.base.__Base__</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hybridq.extras.gate.gate.MessageGate" href="../extras/gate/gate.html#hybridq.extras.gate.gate.MessageGate">MessageGate</a></li>
<li>hybridq.noise.channel.channel._MatrixChannel</li>
</ul>
</dd>
<dt id="hybridq.base.property.Params"><code class="flex name class">
<span>class <span class="ident">Params</span></span>
<span>(</span><span>params: iter[any] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add parameters to class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>iter[any]</code>, optional</dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Params(__Base__):
    &#34;&#34;&#34;
    Add parameters to class.

    Attributes
    ----------
    params: iter[any], optional
    &#34;&#34;&#34;

    def __init__(self, params: iter[any] = None, **kwargs) -&gt; None:
        # Call super
        super().__init__(**kwargs)

        # Set params
        self._set_params(params)

    @property
    def params(self) -&gt; tuple[any]:
        return self.__params

    def __print__(self) -&gt; dict[str, tuple[int, str, int]]:
        return {
            &#39;n_params&#39;:
                (11, f&#34;n_params={self.n_params}&#34; if self.params is None else &#39;&#39;,
                 0),
            &#39;params&#39;: (101, f&#34;params={self.params}&#34; if self.params else &#34;&#34;, 0),
        }

    def _set_params(self, params: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Set `params` to `Params`.
        &#34;&#34;&#34;

        self.set_params(params, inplace=True)

    def set_params(self, params: iter[any], *, inplace: bool = False) -&gt; Params:
        &#34;&#34;&#34;
        Return `Params` with given `params`. If `inplace` is `True`,
        `Params` is modified in place.

        Parameters
        ----------
        params: iter[any]
            Parameters used to define the new Params.
        inplace: bool, optional
            If `True`, `Params` is modified in place. Otherwise, a new
            `Params` is returned.

        Returns
        -------
        Params
            New `Params` with `params`. If `inplace` is `True`, `Params`
            is modified in place.
        &#34;&#34;&#34;

        # Set default
        if params is None and self.n_params == 0:
            params = tuple()

        # Check params is tuple convertible
        if params is not None:
            try:
                params = tuple(params)
            except:
                raise ValueError(&#34;&#39;params&#39; must be &#39;tuple&#39; convertible.&#34;)

        # Check lenght
        if params is not None and len(params) != self.n_params:
            raise ValueError(f&#34;Wrong number of &#39;params&#39; &#34;
                             f&#34;(expected {self.n_params}, got {len(params)})&#34;)

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # Set
        _g.__params = params

        # Return
        return _g</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>hybridq.base.base.__Base__</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hybridq.gate.property.ParamGate" href="../gate/property.html#hybridq.gate.property.ParamGate">ParamGate</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hybridq.base.property.Params.params"><code class="name">var <span class="ident">params</span> : tuple[any]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params(self) -&gt; tuple[any]:
    return self.__params</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hybridq.base.property.Params.set_params"><code class="name flex">
<span>def <span class="ident">set_params</span></span>(<span>self, params: iter[any], *, inplace: bool = False) ‑> <a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></code> with given <code>params</code>. If <code>inplace</code> is <code>True</code>,
<code><a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></code> is modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>iter[any]</code></dt>
<dd>Parameters used to define the new Params.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></code> is modified in place. Otherwise, a new
<code><a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></code> is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></code></dt>
<dd>New <code><a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></code> with <code>params</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></code>
is modified in place.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_params(self, params: iter[any], *, inplace: bool = False) -&gt; Params:
    &#34;&#34;&#34;
    Return `Params` with given `params`. If `inplace` is `True`,
    `Params` is modified in place.

    Parameters
    ----------
    params: iter[any]
        Parameters used to define the new Params.
    inplace: bool, optional
        If `True`, `Params` is modified in place. Otherwise, a new
        `Params` is returned.

    Returns
    -------
    Params
        New `Params` with `params`. If `inplace` is `True`, `Params`
        is modified in place.
    &#34;&#34;&#34;

    # Set default
    if params is None and self.n_params == 0:
        params = tuple()

    # Check params is tuple convertible
    if params is not None:
        try:
            params = tuple(params)
        except:
            raise ValueError(&#34;&#39;params&#39; must be &#39;tuple&#39; convertible.&#34;)

    # Check lenght
    if params is not None and len(params) != self.n_params:
        raise ValueError(f&#34;Wrong number of &#39;params&#39; &#34;
                         f&#34;(expected {self.n_params}, got {len(params)})&#34;)

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    # Set
    _g.__params = params

    # Return
    return _g</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hybridq.base.property.Tags"><code class="flex name class">
<span>class <span class="ident">Tags</span></span>
<span>(</span><span>tags: dict[any, any] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add tags to a object.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>dict[any, any]</code>, optional</dt>
<dd>Dictionary of tags.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tags(__Base__):
    &#34;&#34;&#34;
    Add tags to a object.

    Attributes
    ----------
    tags: dict[any, any], optional
        Dictionary of tags.
    &#34;&#34;&#34;

    def __init__(self, tags: dict[any, any] = None, **kwargs) -&gt; None:
        # Call super
        super().__init__(**kwargs)

        # Set tags
        self.__tags = {} if tags is None else dict(tags)

    def __print__(self) -&gt; dict[str, tuple[int, str, int]]:
        return {&#39;tags&#39;: (999, f&#39;tags={self.tags}&#39; if self.tags else &#39;&#39;, 0)}

    @property
    def tags(self) -&gt; dict[any, any]:
        return self.__tags

    def _set_tags(self, tags: dict[any, any]) -&gt; None:
        &#34;&#34;&#34;
        Set `tags` to `Tags`.
        &#34;&#34;&#34;

        self.set_tags(tags, inplace=True)

    def set_tags(self,
                 tags: dict[any, any] = None,
                 *,
                 inplace: bool = False) -&gt; Tags:
        &#34;&#34;&#34;
        Return `Tags` with given `tags`. All previous tags are removed and
        substituted with `tags`. If `inplace` is `True`, `Tags` is modified
        in place.

        Parameters
        ----------
        tags: dict[any, any]
            Parameters used to define the new `Tags`.
        inplace: bool, optional
            If `True`, `Tags` is modified in place. Otherwise, a new
            `Tags` is returned.

        Returns
        -------
        Tags
            New `Tags` with `tags`. If `inplace` is `True`, `Tags` is
            modified in place.
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # If tags is not None, set tags
        if tags is not None:

            # Assign tags
            _g.__tags = dict(tags)

        # Otherwise, remove tags
        else:

            # Clear tags
            _g.__tags.clear()

        return _g

    def _update_tags(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Update `Tags`&#39;s `tags`.
        &#34;&#34;&#34;

        self.update_tags(*args, **kwargs, inplace=True)

    def update_tags(self, *args, inplace: bool = False, **kwargs) -&gt; Tags:
        &#34;&#34;&#34;
        Return `Tags` with updated tags. If `inplace` is `True`, `Tags` is
        modified in place.

        Parameters
        ----------
        inplace: bool, optional
            If `True`, `Tags` is modified in place. Otherwise, a new `Tags` is
            returned.

        Returns
        -------
        Tags
            New `Tags` with updated tags. If `inplace` is `True`, `Tags` is
            modified in place.
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # Update tags
        _g.tags.update(*args, **kwargs)

        return _g

    def _remove_tags(self, keys: iter[any]) -&gt; None:
        &#34;&#34;&#34;
        Remove tags matching `keys`.
        &#34;&#34;&#34;

        self.remove_tags(keys, inplace=True)

    def remove_tags(self, keys: iter[any], *, inplace: bool = False) -&gt; Tags:
        &#34;&#34;&#34;
        Return `Tags` with removed tags matching `keys`. If `inplace` is
        `True`, `Tags` is modified in place.

        Parameters
        ----------
        keys: iter[any]
            Keys to remove from tags.
        inplace: bool, optional
            If `True`, `Tags` is modified in place. Otherwise, a new
            `Tags` is returned.

        Returns
        -------
        Tags
            New `Tags` with `keys` in tags removed. If `inplace` is `True`,
            `Tags` is modified in place.
        &#34;&#34;&#34;

        # Make a copy if needed
        if inplace:
            _g = self
        else:
            _g = deepcopy(self)

        # Convert to set
        keys = set(keys)

        # Remove tags
        _g._set_tags({k: v for k, v in _g.tags.items() if k not in keys})

        return _g

    def _remove_tag(self, key: any) -&gt; None:
        &#34;&#34;&#34;
        Remove tag matching `key`.
        &#34;&#34;&#34;

        self.remove_tag(key, inplace=True)

    def remove_tag(self, key: any, *, inplace: bool = False) -&gt; Tags:
        &#34;&#34;&#34;
        Return `Tags` with removed tag mathcing `key`. If `inplace` is
        `True`, `Tags` is modified in place.

        Parameters
        ----------
        key: any
            Key to remove from tags.
        inplace: bool, optional
            If `True`, `Tags` is modified in place. Otherwise, a new
            `Tags` is returned.

        Returns
        -------
        Tags
            New `Tags` with `key` in tags removed. If `inplace` is `True`,
            `Tags` is modified in place.
        &#34;&#34;&#34;

        return self.remove_tags([key], inplace=inplace)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>hybridq.base.base.__Base__</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hybridq.base.property.Tuple" href="#hybridq.base.property.Tuple">Tuple</a></li>
<li><a title="hybridq.extras.gate.gate.MessageGate" href="../extras/gate/gate.html#hybridq.extras.gate.gate.MessageGate">MessageGate</a></li>
<li>hybridq.noise.channel.channel._MatrixChannel</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hybridq.base.property.Tags.tags"><code class="name">var <span class="ident">tags</span> : dict[any, any]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tags(self) -&gt; dict[any, any]:
    return self.__tags</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hybridq.base.property.Tags.remove_tag"><code class="name flex">
<span>def <span class="ident">remove_tag</span></span>(<span>self, key: any, *, inplace: bool = False) ‑> <a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> with removed tag mathcing <code>key</code>. If <code>inplace</code> is
<code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>any</code></dt>
<dd>Key to remove from tags.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified in place. Otherwise, a new
<code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code></dt>
<dd>New <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> with <code>key</code> in tags removed. If <code>inplace</code> is <code>True</code>,
<code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified in place.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_tag(self, key: any, *, inplace: bool = False) -&gt; Tags:
    &#34;&#34;&#34;
    Return `Tags` with removed tag mathcing `key`. If `inplace` is
    `True`, `Tags` is modified in place.

    Parameters
    ----------
    key: any
        Key to remove from tags.
    inplace: bool, optional
        If `True`, `Tags` is modified in place. Otherwise, a new
        `Tags` is returned.

    Returns
    -------
    Tags
        New `Tags` with `key` in tags removed. If `inplace` is `True`,
        `Tags` is modified in place.
    &#34;&#34;&#34;

    return self.remove_tags([key], inplace=inplace)</code></pre>
</details>
</dd>
<dt id="hybridq.base.property.Tags.remove_tags"><code class="name flex">
<span>def <span class="ident">remove_tags</span></span>(<span>self, keys: iter[any], *, inplace: bool = False) ‑> <a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> with removed tags matching <code>keys</code>. If <code>inplace</code> is
<code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>keys</code></strong> :&ensp;<code>iter[any]</code></dt>
<dd>Keys to remove from tags.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified in place. Otherwise, a new
<code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code></dt>
<dd>New <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> with <code>keys</code> in tags removed. If <code>inplace</code> is <code>True</code>,
<code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified in place.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_tags(self, keys: iter[any], *, inplace: bool = False) -&gt; Tags:
    &#34;&#34;&#34;
    Return `Tags` with removed tags matching `keys`. If `inplace` is
    `True`, `Tags` is modified in place.

    Parameters
    ----------
    keys: iter[any]
        Keys to remove from tags.
    inplace: bool, optional
        If `True`, `Tags` is modified in place. Otherwise, a new
        `Tags` is returned.

    Returns
    -------
    Tags
        New `Tags` with `keys` in tags removed. If `inplace` is `True`,
        `Tags` is modified in place.
    &#34;&#34;&#34;

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    # Convert to set
    keys = set(keys)

    # Remove tags
    _g._set_tags({k: v for k, v in _g.tags.items() if k not in keys})

    return _g</code></pre>
</details>
</dd>
<dt id="hybridq.base.property.Tags.set_tags"><code class="name flex">
<span>def <span class="ident">set_tags</span></span>(<span>self, tags: dict[any, any] = None, *, inplace: bool = False) ‑> <a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> with given <code>tags</code>. All previous tags are removed and
substituted with <code>tags</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified
in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>dict[any, any]</code></dt>
<dd>Parameters used to define the new <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code>.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified in place. Otherwise, a new
<code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code></dt>
<dd>New <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> with <code>tags</code>. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is
modified in place.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tags(self,
             tags: dict[any, any] = None,
             *,
             inplace: bool = False) -&gt; Tags:
    &#34;&#34;&#34;
    Return `Tags` with given `tags`. All previous tags are removed and
    substituted with `tags`. If `inplace` is `True`, `Tags` is modified
    in place.

    Parameters
    ----------
    tags: dict[any, any]
        Parameters used to define the new `Tags`.
    inplace: bool, optional
        If `True`, `Tags` is modified in place. Otherwise, a new
        `Tags` is returned.

    Returns
    -------
    Tags
        New `Tags` with `tags`. If `inplace` is `True`, `Tags` is
        modified in place.
    &#34;&#34;&#34;

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    # If tags is not None, set tags
    if tags is not None:

        # Assign tags
        _g.__tags = dict(tags)

    # Otherwise, remove tags
    else:

        # Clear tags
        _g.__tags.clear()

    return _g</code></pre>
</details>
</dd>
<dt id="hybridq.base.property.Tags.update_tags"><code class="name flex">
<span>def <span class="ident">update_tags</span></span>(<span>self, *args, inplace: bool = False, **kwargs) ‑> <a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> with updated tags. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is
modified in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is modified in place. Otherwise, a new <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is
returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code></dt>
<dd>New <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> with updated tags. If <code>inplace</code> is <code>True</code>, <code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code> is
modified in place.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tags(self, *args, inplace: bool = False, **kwargs) -&gt; Tags:
    &#34;&#34;&#34;
    Return `Tags` with updated tags. If `inplace` is `True`, `Tags` is
    modified in place.

    Parameters
    ----------
    inplace: bool, optional
        If `True`, `Tags` is modified in place. Otherwise, a new `Tags` is
        returned.

    Returns
    -------
    Tags
        New `Tags` with updated tags. If `inplace` is `True`, `Tags` is
        modified in place.
    &#34;&#34;&#34;

    # Make a copy if needed
    if inplace:
        _g = self
    else:
        _g = deepcopy(self)

    # Update tags
    _g.tags.update(*args, **kwargs)

    return _g</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hybridq.base.property.Tuple"><code class="flex name class">
<span>class <span class="ident">Tuple</span></span>
<span>(</span><span>elements=(), tags=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Tuple class for <code>__Base__</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tuple(Tags, __Base__):
    &#34;&#34;&#34;
    Tuple class for `__Base__`.
    &#34;&#34;&#34;

    def __init__(self, elements=tuple(), tags=None, **kwargs):
        # Call super
        super().__init__(tags=tags, **kwargs)

        # Convert elements to tuple
        elements = tuple(elements)

        # Check that all elements are __Base__
        if not all(isinstance(el, __Base__) for el in elements):
            raise TypeError(f&#34;Only &#39;__Base__&#39; elements are supported&#34;)

        # Get possible basis
        _base_check = self.__get_staticvar__(&#39;_base_check&#39;)

        if _base_check and not all(
                f(isinstance(el, t)
                  for t in ts)
                for el in elements
                for f, ts in _base_check.items()):
            raise TypeError(
                f&#34;Only {self.__get_staticvar__(&#39;_base_check&#39;)} elements are supported&#34;
            )

        # Initialize elements
        self.__elements = elements

    @property
    def elements(self):
        return self.__elements

    def __len__(self) -&gt; int:
        return len(self.elements)

    def __print__(self) -&gt; dict[str, tuple[int, str, int]]:
        # Get string representation
        _el = &#39;, &#39;.join(str(e) for e in self.elements)

        # Return representation
        return dict(elements=(0, _el if len(self) else &#39;&#39;, 0))

    def __getitem__(self, *args, **kwargs):
        # Get elements
        return self.elements.__getitem__(*args, **kwargs)

    def index(self, *args, **kwargs):
        # Get index
        return self.elements.index(*args, **kwargs)

    def __radd__(self, other: Tuple):
        # If &#39;other&#39; is &#39;tuple&#39; try to convert ..
        if isinstance(other, tuple):
            # .. to type(self) or ..
            try:
                other = type(self)(other)

            # .. to Tuple.
            except:
                other = Tuple(other)

        # Check that other is a Tuple
        if not isinstance(other, Tuple):
            raise TypeError(f&#34;Type &#39;{type(other).__name__}&#39; not supported&#34;)

        # Return Tuple. If self and other have different types, fallback to Type.
        return (type(self) if type(self) == type(other) else
                Tuple)(other.elements + self.elements)

    def __add__(self, other: Tuple) -&gt; Tuple:
        # If &#39;other&#39; is &#39;tuple&#39; try to convert ..
        if isinstance(other, tuple):
            # .. to type(self) or ..
            try:
                other = type(self)(other)

            # .. to Tuple.
            except:
                other = Tuple(other)

        # &#39;other&#39; must be Tuple
        if not isinstance(other, Tuple):
            raise TypeError(f&#34;Type &#39;{type(other).__name__}&#39; not supported&#34;)

        # Get left and right tags
        l_tags = self.tags if self.provides(&#39;tags&#39;) else {}
        r_tags = other.tags if other.provides(&#39;tags&#39;) else {}

        # Get common keys
        ckeys = set(l_tags).intersection(r_tags)

        # Create new tags
        tags = {}
        tags.update({
            (str(k) + &#39;_x&#39; if k in ckeys else k): v for k, v in l_tags.items()
        })
        tags.update({
            (str(k) + &#39;_y&#39; if k in ckeys else k): v for k, v in r_tags.items()
        })

        # If self and other have different types, fallback to Tuple
        other = (type(self) if type(self) == type(other) else
                 Tuple)(self.elements + other.elements)

        # Update tags and return
        return other.update_tags(tags, inplace=True)

    def flatten(self) -&gt; Tuple:
        &#34;&#34;&#34;
        Return a flattend `Tuple`.
        &#34;&#34;&#34;
        return type(self)(y for x in (g.flatten(
        ) if isinstance(g, Tuple) and g.provides(&#39;flatten&#39;) else [g]
                                      for g in self) for y in x)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></li>
<li>hybridq.base.base.__Base__</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hybridq.dm.gate.property.BaseTupleSuperGate" href="../dm/gate/property.html#hybridq.dm.gate.property.BaseTupleSuperGate">BaseTupleSuperGate</a></li>
<li><a title="hybridq.gate.property.BaseTupleGate" href="../gate/property.html#hybridq.gate.property.BaseTupleGate">BaseTupleGate</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hybridq.base.property.Tuple.elements"><code class="name">var <span class="ident">elements</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self):
    return self.__elements</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hybridq.base.property.Tuple.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self) ‑> <a title="hybridq.base.property.Tuple" href="#hybridq.base.property.Tuple">Tuple</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a flattend <code><a title="hybridq.base.property.Tuple" href="#hybridq.base.property.Tuple">Tuple</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(self) -&gt; Tuple:
    &#34;&#34;&#34;
    Return a flattend `Tuple`.
    &#34;&#34;&#34;
    return type(self)(y for x in (g.flatten(
    ) if isinstance(g, Tuple) and g.provides(&#39;flatten&#39;) else [g]
                                  for g in self) for y in x)</code></pre>
</details>
</dd>
<dt id="hybridq.base.property.Tuple.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self, *args, **kwargs):
    # Get index
    return self.elements.index(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></b></code>:
<ul class="hlist">
<li><code><a title="hybridq.base.property.Tags.remove_tag" href="#hybridq.base.property.Tags.remove_tag">remove_tag</a></code></li>
<li><code><a title="hybridq.base.property.Tags.remove_tags" href="#hybridq.base.property.Tags.remove_tags">remove_tags</a></code></li>
<li><code><a title="hybridq.base.property.Tags.set_tags" href="#hybridq.base.property.Tags.set_tags">set_tags</a></code></li>
<li><code><a title="hybridq.base.property.Tags.update_tags" href="#hybridq.base.property.Tags.update_tags">update_tags</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq.base" href="index.html">hybridq.base</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hybridq.base.property.DocString" href="#hybridq.base.property.DocString">DocString</a></code></h4>
</li>
<li>
<h4><code><a title="hybridq.base.property.Name" href="#hybridq.base.property.Name">Name</a></code></h4>
</li>
<li>
<h4><code><a title="hybridq.base.property.Params" href="#hybridq.base.property.Params">Params</a></code></h4>
<ul class="">
<li><code><a title="hybridq.base.property.Params.params" href="#hybridq.base.property.Params.params">params</a></code></li>
<li><code><a title="hybridq.base.property.Params.set_params" href="#hybridq.base.property.Params.set_params">set_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hybridq.base.property.Tags" href="#hybridq.base.property.Tags">Tags</a></code></h4>
<ul class="">
<li><code><a title="hybridq.base.property.Tags.remove_tag" href="#hybridq.base.property.Tags.remove_tag">remove_tag</a></code></li>
<li><code><a title="hybridq.base.property.Tags.remove_tags" href="#hybridq.base.property.Tags.remove_tags">remove_tags</a></code></li>
<li><code><a title="hybridq.base.property.Tags.set_tags" href="#hybridq.base.property.Tags.set_tags">set_tags</a></code></li>
<li><code><a title="hybridq.base.property.Tags.tags" href="#hybridq.base.property.Tags.tags">tags</a></code></li>
<li><code><a title="hybridq.base.property.Tags.update_tags" href="#hybridq.base.property.Tags.update_tags">update_tags</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hybridq.base.property.Tuple" href="#hybridq.base.property.Tuple">Tuple</a></code></h4>
<ul class="">
<li><code><a title="hybridq.base.property.Tuple.elements" href="#hybridq.base.property.Tuple.elements">elements</a></code></li>
<li><code><a title="hybridq.base.property.Tuple.flatten" href="#hybridq.base.property.Tuple.flatten">flatten</a></code></li>
<li><code><a title="hybridq.base.property.Tuple.index" href="#hybridq.base.property.Tuple.index">index</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>