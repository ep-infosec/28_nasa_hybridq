<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hybridq.dm.gate.gate API documentation</title>
<meta name="description" content="Author: Salvatore Mandra (salvatore.mandra@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.dm.gate.gate</code></h1>
</header>
<section id="section-intro">
<p>Author: Salvatore Mandra (salvatore.mandra@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Salvatore Mandra (salvatore.mandra@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
from hybridq.gate import property as pr
from hybridq.dm.gate import property as dm_pr
import numpy as np


class BaseSuperGate(dm_pr.__Base__):
    &#34;&#34;&#34;
    Common type for all gates.
    &#34;&#34;&#34;
    pass


def TupleSuperGate(gates: iter[{BaseGate, BaseSuperGate}] = tuple(),
                   tags: dict[any, any] = None) -&gt; TupleSuperGate:
    &#34;&#34;&#34;
    Generate a tuple gate.

    Parameters
    ----------
    gates: iter[{BaseGate, BaseSuperGate}]
        `gates` used to initialize the `TupleGate`.
    tags: dict[any, any], optional
        Dictionary of tags.

    Returns
    -------
    TupleSuperGate
    &#34;&#34;&#34;
    from hybridq.gate.gate import BaseGate

    # Return gate
    return pr.generate(&#39;TupleSuperGate&#39;,
                       (BaseSuperGate, dm_pr.BaseTupleSuperGate, pr.NameGate),
                       name=&#39;STUPLE&#39;,
                       _base_check={any: [BaseGate, BaseSuperGate]})(gates,
                                                                     tags=tags)


@dm_pr.staticvars(&#39;l_qubits,r_qubits&#39;)
class _MatrixSuperGate(BaseSuperGate):
    pass


def MatrixSuperGate(Map: np.ndarray,
                    l_qubits: iter[any],
                    r_qubits: iter[any] = None,
                    tags: dict[any, any] = None,
                    copy: bool = True) -&gt; MatrixSuperGate:
    &#34;&#34;&#34;
    Return a MatrixSuperGate.

    Parameters
    ----------
    Map: np.ndarray
        Map representing the `SuperGate`.
    l_qubits, r_qubits: iter[any], iter[any]
        Left (right respectively) qubits for the `Map`. If r_qubits is not
        provided, `r_qubits` is assumed to be equal to `l_qubits`.
    tags: dict[any, any], optional
        Dictionary of tags.
    copy: bool, optional
        A copy of `Map` is used instead of a reference if `copy` is True
        (default: True).

    Returns
    -------
    MatrixSuperGate
    &#34;&#34;&#34;

    def __print_qubits__(self):
        return {
            &#39;l_qubits&#39;:
                (100, f&#39;l_qubits={pr._truncate_print(self.qubits[0])}&#39;, 0),
            &#39;r_qubits&#39;:
                (101, f&#39;r_qubits={pr._truncate_print(self.qubits[1])}&#39;, 0),
        }

    # Get Map
    Map = (np.array if copy else np.asarray)(Map)

    # Get qubits
    l_qubits = tuple(l_qubits)
    r_qubits = l_qubits if r_qubits is None else tuple(r_qubits)
    n_qubits = len(l_qubits) + len(r_qubits)

    # Check consistency
    if Map.shape != (2**n_qubits, 2**n_qubits):
        raise ValueError(
            &#34;&#39;Map&#39; must be consistent with the total number of qubits.&#34;)

    # Get MatrixSuperGate
    return dm_pr.generate(
        &#34;MatrixSuperGate&#34;,
        (_MatrixSuperGate, dm_pr.Map, pr.MatrixGate, pr.TagGate, pr.NameGate),
        methods=dict(
            qubits=property(lambda self: (self.l_qubits, self.r_qubits)),
            n_qubits=property(lambda self: tuple(len(q) for q in self.qubits)),
            __print__=__print_qubits__),
        name=&#39;SMATRIX&#39;,
        l_qubits=l_qubits,
        r_qubits=r_qubits,
        Matrix=Map)(tags=tags)


def KrausSuperGate(gates: {iter[Gate], tuple[iter[Gate], iter[Gate]]},
                   s: any = 1,
                   tags: dict[any, any] = None,
                   copy: bool = True,
                   use_cache: bool = True) -&gt; KrausSuperGate:
    &#34;&#34;&#34;
    Return a KrausSuperGate.

    Parameters
    ----------
    gates: {iter[Gate], tuple[iter[Gate], iter[Gate]]}
        List of valid `Gate`s representing the `KrausSuperGate`. If `gates` is
        a pair of list of `Gate`s, the first list is used for the left-hand
        side `Gate`s of the `KrausSuperGate`, while the second list is used for
        the right-hand side `Gate`s of `KrausSuperGate`. If `gates` is a single
        list of `Gate`&#39;s, left/right-hand side `Gates` of the `KrausSuperGate`
        are assumed to be the same.
    s: np.ndarray
        Correlation matrix between left/right-hand side `Gate`s of the
        `KrausSuperOperator`. More precisely, `KrausSuperOperator` will act on
        a dentity matrix ρ as:
        ```
        K(ρ) = \sum_{ij} s_ij L_i ρ R_j^+
        ```
        `s` can be a single scalar, a vector or a matrix consistent with the
        number of gates.
    tags: dict[any, any], optional
        Dictionary of tags.
    copy: bool, optional
        A copy of `gates` and `s` is used instead of a reference if `copy` is
        `True` (default: True).
    use_cache: bool, optional
        If `True`, extra memory is used to store a cached `Matrix`.

    Returns
    -------
    KrausSuperGate
    &#34;&#34;&#34;
    from hybridq.gate import TupleGate

    # Copy if needed
    def _copy(x: iter[any, ...]):
        from copy import deepcopy
        return (deepcopy(y) for y in x) if copy else x

    def __print_qubits__(self):
        return {
            &#39;l_qubits&#39;: (100, &#39;&#39; if self.qubits[0] is None else
                         f&#39;l_qubits={pr._truncate_print(self.qubits[0])}&#39;, 0),
            &#39;r_qubits&#39;: (101, &#39;&#39; if self.qubits[1] is None else
                         f&#39;r_qubits={pr._truncate_print(self.qubits[1])}&#39;, 0),
        }

    # Get gates
    gates = tuple(gates)

    # Get left and right gates
    try:
        # Try by first assuming that &#39;gates&#39; is a tuple of gates ...
        l_gates, r_gates = gates
        l_gates = TupleGate(_copy(l_gates))
        r_gates = TupleGate(_copy(r_gates))

    # ... if an error occurs ...
    except:
        try:
            # ... try as a single tuple of gates.
            l_gates = TupleGate(_copy(gates))
            r_gates = _copy(l_gates)

        except:
            # Finally, raise an error.
            raise ValueError(&#34;&#39;gates&#39; must be either a single list &#34;
                             &#34;of &#39;Gate&#39;s or a pair of lists of &#39;Gate&#39;s&#34;)

    # If r_gates is not empty, l_gates must be not empty
    if r_gates and not l_gates:
        raise ValueError(&#34;&#39;l_gates&#39; cannot be empty if &#39;r_gates&#39; is provided&#34;)

    return dm_pr.generate(
        &#39;KrausSuperGate&#39;,
        (BaseSuperGate, pr.SchmidtGate, dm_pr.Map, pr.TagGate, pr.NameGate),
        methods=dict(qubits=property(
            lambda self: (self.gates[0].qubits, self.gates[1].qubits)),
                     n_qubits=property(lambda self: tuple(
                         None if q is None else len(q) for q in self.qubits)),
                     __print__=__print_qubits__),
        gates=(l_gates, r_gates),
        s=(np.array if copy else np.asarray)(s),
        _conj_rgates=True,
        name=&#39;KRAUS&#39;,
        _use_cache=use_cache)(tags=tags)


# Define gate aliases
_gate_aliases = {
    &#39;KSG&#39;: &#39;KRAUS&#39;,
    &#39;MSG&#39;: &#39;SMATRIX&#39;,
}


def Gate(name: str, **kwargs):
    # To upper
    name = name.upper()

    # Check if an alias is used
    if name in _gate_aliases:
        warn(f&#34;&#39;{name}&#39; is an alias for &#39;{_gate_aliases[name]}&#39;. &#34;
             &#34;Using Gate(name=&#39;{_gate_aliases[name]}&#39;).&#34;)
        name = _gate_aliases[name]

    # Return gate
    if name == &#39;KRAUS&#39;:
        return KrausSuperGate(**kwargs)
    elif name == &#39;SMATRIX&#39;:
        return MatrixSuperGate(**kwargs)
    elif name == &#39;STUPLE&#39;:
        return TupleSuperGate(**kwargs)
    else:
        raise NotImplementedError(f&#34;&#39;{name}&#39; not implemented.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hybridq.dm.gate.gate.Gate"><code class="name flex">
<span>def <span class="ident">Gate</span></span>(<span>name: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Gate(name: str, **kwargs):
    # To upper
    name = name.upper()

    # Check if an alias is used
    if name in _gate_aliases:
        warn(f&#34;&#39;{name}&#39; is an alias for &#39;{_gate_aliases[name]}&#39;. &#34;
             &#34;Using Gate(name=&#39;{_gate_aliases[name]}&#39;).&#34;)
        name = _gate_aliases[name]

    # Return gate
    if name == &#39;KRAUS&#39;:
        return KrausSuperGate(**kwargs)
    elif name == &#39;SMATRIX&#39;:
        return MatrixSuperGate(**kwargs)
    elif name == &#39;STUPLE&#39;:
        return TupleSuperGate(**kwargs)
    else:
        raise NotImplementedError(f&#34;&#39;{name}&#39; not implemented.&#34;)</code></pre>
</details>
</dd>
<dt id="hybridq.dm.gate.gate.KrausSuperGate"><code class="name flex">
<span>def <span class="ident">KrausSuperGate</span></span>(<span>gates: {iter[<a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a>], tuple[iter[<a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a>], iter[<a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a>]]}, s: any = 1, tags: dict[any, any] = None, copy: bool = True, use_cache: bool = True) ‑> <a title="hybridq.dm.gate.gate.KrausSuperGate" href="#hybridq.dm.gate.gate.KrausSuperGate">KrausSuperGate()</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a KrausSuperGate.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gates</code></strong> :&ensp;<code>{iter[Gate], tuple[iter[Gate], iter[Gate]]}</code></dt>
<dd>List of valid <code><a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a></code>s representing the <code><a title="hybridq.dm.gate.gate.KrausSuperGate" href="#hybridq.dm.gate.gate.KrausSuperGate">KrausSuperGate()</a></code>. If <code>gates</code> is
a pair of list of <code><a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a></code>s, the first list is used for the left-hand
side <code><a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a></code>s of the <code><a title="hybridq.dm.gate.gate.KrausSuperGate" href="#hybridq.dm.gate.gate.KrausSuperGate">KrausSuperGate()</a></code>, while the second list is used for
the right-hand side <code><a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a></code>s of <code><a title="hybridq.dm.gate.gate.KrausSuperGate" href="#hybridq.dm.gate.gate.KrausSuperGate">KrausSuperGate()</a></code>. If <code>gates</code> is a single
list of <code><a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a></code>'s, left/right-hand side <code>Gates</code> of the <code><a title="hybridq.dm.gate.gate.KrausSuperGate" href="#hybridq.dm.gate.gate.KrausSuperGate">KrausSuperGate()</a></code>
are assumed to be the same.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Correlation matrix between left/right-hand side <code><a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate()</a></code>s of the
<code>KrausSuperOperator</code>. More precisely, <code>KrausSuperOperator</code> will act on
a dentity matrix ρ as:
<code>K(ρ) = \sum_{ij} s_ij L_i ρ R_j^+</code>
<code>s</code> can be a single scalar, a vector or a matrix consistent with the
number of gates.</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>dict[any, any]</code>, optional</dt>
<dd>Dictionary of tags.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>A copy of <code>gates</code> and <code>s</code> is used instead of a reference if <code>copy</code> is
<code>True</code> (default: True).</dd>
<dt><strong><code>use_cache</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, extra memory is used to store a cached <code>Matrix</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.dm.gate.gate.KrausSuperGate" href="#hybridq.dm.gate.gate.KrausSuperGate">KrausSuperGate()</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def KrausSuperGate(gates: {iter[Gate], tuple[iter[Gate], iter[Gate]]},
                   s: any = 1,
                   tags: dict[any, any] = None,
                   copy: bool = True,
                   use_cache: bool = True) -&gt; KrausSuperGate:
    &#34;&#34;&#34;
    Return a KrausSuperGate.

    Parameters
    ----------
    gates: {iter[Gate], tuple[iter[Gate], iter[Gate]]}
        List of valid `Gate`s representing the `KrausSuperGate`. If `gates` is
        a pair of list of `Gate`s, the first list is used for the left-hand
        side `Gate`s of the `KrausSuperGate`, while the second list is used for
        the right-hand side `Gate`s of `KrausSuperGate`. If `gates` is a single
        list of `Gate`&#39;s, left/right-hand side `Gates` of the `KrausSuperGate`
        are assumed to be the same.
    s: np.ndarray
        Correlation matrix between left/right-hand side `Gate`s of the
        `KrausSuperOperator`. More precisely, `KrausSuperOperator` will act on
        a dentity matrix ρ as:
        ```
        K(ρ) = \sum_{ij} s_ij L_i ρ R_j^+
        ```
        `s` can be a single scalar, a vector or a matrix consistent with the
        number of gates.
    tags: dict[any, any], optional
        Dictionary of tags.
    copy: bool, optional
        A copy of `gates` and `s` is used instead of a reference if `copy` is
        `True` (default: True).
    use_cache: bool, optional
        If `True`, extra memory is used to store a cached `Matrix`.

    Returns
    -------
    KrausSuperGate
    &#34;&#34;&#34;
    from hybridq.gate import TupleGate

    # Copy if needed
    def _copy(x: iter[any, ...]):
        from copy import deepcopy
        return (deepcopy(y) for y in x) if copy else x

    def __print_qubits__(self):
        return {
            &#39;l_qubits&#39;: (100, &#39;&#39; if self.qubits[0] is None else
                         f&#39;l_qubits={pr._truncate_print(self.qubits[0])}&#39;, 0),
            &#39;r_qubits&#39;: (101, &#39;&#39; if self.qubits[1] is None else
                         f&#39;r_qubits={pr._truncate_print(self.qubits[1])}&#39;, 0),
        }

    # Get gates
    gates = tuple(gates)

    # Get left and right gates
    try:
        # Try by first assuming that &#39;gates&#39; is a tuple of gates ...
        l_gates, r_gates = gates
        l_gates = TupleGate(_copy(l_gates))
        r_gates = TupleGate(_copy(r_gates))

    # ... if an error occurs ...
    except:
        try:
            # ... try as a single tuple of gates.
            l_gates = TupleGate(_copy(gates))
            r_gates = _copy(l_gates)

        except:
            # Finally, raise an error.
            raise ValueError(&#34;&#39;gates&#39; must be either a single list &#34;
                             &#34;of &#39;Gate&#39;s or a pair of lists of &#39;Gate&#39;s&#34;)

    # If r_gates is not empty, l_gates must be not empty
    if r_gates and not l_gates:
        raise ValueError(&#34;&#39;l_gates&#39; cannot be empty if &#39;r_gates&#39; is provided&#34;)

    return dm_pr.generate(
        &#39;KrausSuperGate&#39;,
        (BaseSuperGate, pr.SchmidtGate, dm_pr.Map, pr.TagGate, pr.NameGate),
        methods=dict(qubits=property(
            lambda self: (self.gates[0].qubits, self.gates[1].qubits)),
                     n_qubits=property(lambda self: tuple(
                         None if q is None else len(q) for q in self.qubits)),
                     __print__=__print_qubits__),
        gates=(l_gates, r_gates),
        s=(np.array if copy else np.asarray)(s),
        _conj_rgates=True,
        name=&#39;KRAUS&#39;,
        _use_cache=use_cache)(tags=tags)</code></pre>
</details>
</dd>
<dt id="hybridq.dm.gate.gate.MatrixSuperGate"><code class="name flex">
<span>def <span class="ident">MatrixSuperGate</span></span>(<span>Map: np.ndarray, l_qubits: iter[any], r_qubits: iter[any] = None, tags: dict[any, any] = None, copy: bool = True) ‑> <a title="hybridq.dm.gate.gate.MatrixSuperGate" href="#hybridq.dm.gate.gate.MatrixSuperGate">MatrixSuperGate()</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a MatrixSuperGate.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Map</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Map representing the <code>SuperGate</code>.</dd>
<dt><strong><code>l_qubits</code></strong>, <strong><code>r_qubits</code></strong> :&ensp;<code>iter[any], iter[any]</code></dt>
<dd>Left (right respectively) qubits for the <code>Map</code>. If r_qubits is not
provided, <code>r_qubits</code> is assumed to be equal to <code>l_qubits</code>.</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>dict[any, any]</code>, optional</dt>
<dd>Dictionary of tags.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>A copy of <code>Map</code> is used instead of a reference if <code>copy</code> is True
(default: True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.dm.gate.gate.MatrixSuperGate" href="#hybridq.dm.gate.gate.MatrixSuperGate">MatrixSuperGate()</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MatrixSuperGate(Map: np.ndarray,
                    l_qubits: iter[any],
                    r_qubits: iter[any] = None,
                    tags: dict[any, any] = None,
                    copy: bool = True) -&gt; MatrixSuperGate:
    &#34;&#34;&#34;
    Return a MatrixSuperGate.

    Parameters
    ----------
    Map: np.ndarray
        Map representing the `SuperGate`.
    l_qubits, r_qubits: iter[any], iter[any]
        Left (right respectively) qubits for the `Map`. If r_qubits is not
        provided, `r_qubits` is assumed to be equal to `l_qubits`.
    tags: dict[any, any], optional
        Dictionary of tags.
    copy: bool, optional
        A copy of `Map` is used instead of a reference if `copy` is True
        (default: True).

    Returns
    -------
    MatrixSuperGate
    &#34;&#34;&#34;

    def __print_qubits__(self):
        return {
            &#39;l_qubits&#39;:
                (100, f&#39;l_qubits={pr._truncate_print(self.qubits[0])}&#39;, 0),
            &#39;r_qubits&#39;:
                (101, f&#39;r_qubits={pr._truncate_print(self.qubits[1])}&#39;, 0),
        }

    # Get Map
    Map = (np.array if copy else np.asarray)(Map)

    # Get qubits
    l_qubits = tuple(l_qubits)
    r_qubits = l_qubits if r_qubits is None else tuple(r_qubits)
    n_qubits = len(l_qubits) + len(r_qubits)

    # Check consistency
    if Map.shape != (2**n_qubits, 2**n_qubits):
        raise ValueError(
            &#34;&#39;Map&#39; must be consistent with the total number of qubits.&#34;)

    # Get MatrixSuperGate
    return dm_pr.generate(
        &#34;MatrixSuperGate&#34;,
        (_MatrixSuperGate, dm_pr.Map, pr.MatrixGate, pr.TagGate, pr.NameGate),
        methods=dict(
            qubits=property(lambda self: (self.l_qubits, self.r_qubits)),
            n_qubits=property(lambda self: tuple(len(q) for q in self.qubits)),
            __print__=__print_qubits__),
        name=&#39;SMATRIX&#39;,
        l_qubits=l_qubits,
        r_qubits=r_qubits,
        Matrix=Map)(tags=tags)</code></pre>
</details>
</dd>
<dt id="hybridq.dm.gate.gate.TupleSuperGate"><code class="name flex">
<span>def <span class="ident">TupleSuperGate</span></span>(<span>gates: iter[{BaseGate, <a title="hybridq.dm.gate.gate.BaseSuperGate" href="#hybridq.dm.gate.gate.BaseSuperGate">BaseSuperGate</a>}] = (), tags: dict[any, any] = None) ‑> <a title="hybridq.dm.gate.gate.TupleSuperGate" href="#hybridq.dm.gate.gate.TupleSuperGate">TupleSuperGate()</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate a tuple gate.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gates</code></strong> :&ensp;<code>iter[{BaseGate, BaseSuperGate}]</code></dt>
<dd><code>gates</code> used to initialize the <code>TupleGate</code>.</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>dict[any, any]</code>, optional</dt>
<dd>Dictionary of tags.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hybridq.dm.gate.gate.TupleSuperGate" href="#hybridq.dm.gate.gate.TupleSuperGate">TupleSuperGate()</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TupleSuperGate(gates: iter[{BaseGate, BaseSuperGate}] = tuple(),
                   tags: dict[any, any] = None) -&gt; TupleSuperGate:
    &#34;&#34;&#34;
    Generate a tuple gate.

    Parameters
    ----------
    gates: iter[{BaseGate, BaseSuperGate}]
        `gates` used to initialize the `TupleGate`.
    tags: dict[any, any], optional
        Dictionary of tags.

    Returns
    -------
    TupleSuperGate
    &#34;&#34;&#34;
    from hybridq.gate.gate import BaseGate

    # Return gate
    return pr.generate(&#39;TupleSuperGate&#39;,
                       (BaseSuperGate, dm_pr.BaseTupleSuperGate, pr.NameGate),
                       name=&#39;STUPLE&#39;,
                       _base_check={any: [BaseGate, BaseSuperGate]})(gates,
                                                                     tags=tags)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hybridq.dm.gate.gate.BaseSuperGate"><code class="flex name class">
<span>class <span class="ident">BaseSuperGate</span></span>
</code></dt>
<dd>
<div class="desc"><p>Common type for all gates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseSuperGate(dm_pr.__Base__):
    &#34;&#34;&#34;
    Common type for all gates.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>hybridq.base.base.__Base__</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>hybridq.dm.gate.gate._MatrixSuperGate</li>
<li>hybridq.noise.channel.channel._MatrixChannel</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq.dm.gate" href="index.html">hybridq.dm.gate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hybridq.dm.gate.gate.Gate" href="#hybridq.dm.gate.gate.Gate">Gate</a></code></li>
<li><code><a title="hybridq.dm.gate.gate.KrausSuperGate" href="#hybridq.dm.gate.gate.KrausSuperGate">KrausSuperGate</a></code></li>
<li><code><a title="hybridq.dm.gate.gate.MatrixSuperGate" href="#hybridq.dm.gate.gate.MatrixSuperGate">MatrixSuperGate</a></code></li>
<li><code><a title="hybridq.dm.gate.gate.TupleSuperGate" href="#hybridq.dm.gate.gate.TupleSuperGate">TupleSuperGate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hybridq.dm.gate.gate.BaseSuperGate" href="#hybridq.dm.gate.gate.BaseSuperGate">BaseSuperGate</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>