<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hybridq.extras.io.cirq API documentation</title>
<meta name="description" content="Author: Salvatore Mandra (salvatore.mandra@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.extras.io.cirq</code></h1>
</header>
<section id="section-intro">
<p>Author: Salvatore Mandra (salvatore.mandra@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Salvatore Mandra (salvatore.mandra@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
from hybridq.circuit import Circuit
from hybridq.gate import Gate
from hybridq.gate.property import QubitGate, ParamGate
from tqdm.auto import tqdm
import numpy as np
import cirq


def to_cirq(circuit: Circuit,
            qubits_map: dict[any, any] = None,
            verbose: bool = False) -&gt; cirq.Circuit:
    &#34;&#34;&#34;
    Convert `Circuit` to `cirq.Circuit`.

    Parameters
    ----------
    circuit: Circuit
        `Circuit` to convert to `cirq.Circuit`.
    qubits_map: dict[any, any], optional
        How to map qubits in `Circuit` to `cirq.Circuit`. if not provided,
        `cirq.LineQubit`s are used and automatically mapped to `Circuit`&#39;s
        qubits.
    verbose: bool, optional
        Verbose output.

    Returns
    -------
    cirq.Circuit
        `cirq.Circuit` obtained from `Circuit`.

    Example
    -------
    &gt;&gt;&gt; from hybridq.extras.cirq import to_cirq
    &gt;&gt;&gt; c = Circuit(Gate(&#39;H&#39;, qubits=[q]) for q in range(3))
    &gt;&gt;&gt; c.append(Gate(&#39;CX&#39;, qubits=[0, 1]))
    &gt;&gt;&gt; c.append(Gate(&#39;CX&#39;, qubits=[2, 0]))
    &gt;&gt;&gt; c.append(Gate(&#39;CX&#39;, qubits=[1, 2]))
    &gt;&gt;&gt; to_cirq(c)
    0: ───H───@───X───────
              │   │
    1: ───H───X───┼───@───
                  │   │
    2: ───H───────@───X───
    &#34;&#34;&#34;

    _to_cirq_naming = {
        &#39;I&#39;: lambda params: cirq.I,
        &#39;P&#39;: lambda params: cirq.S,
        &#39;T&#39;: lambda params: cirq.T,
        &#39;X&#39;: lambda params: cirq.X,
        &#39;Y&#39;: lambda params: cirq.Y,
        &#39;Z&#39;: lambda params: cirq.Z,
        &#39;H&#39;: lambda params: cirq.H,
        &#39;RX&#39;: lambda params: cirq.rx(*params),
        &#39;RY&#39;: lambda params: cirq.ry(*params),
        &#39;RZ&#39;: lambda params: cirq.rz(*params),
        &#39;CZ&#39;: lambda params: cirq.CZ,
        &#39;ZZ&#39;: lambda params: cirq.ZZ,
        &#39;CX&#39;: lambda params: cirq.CNOT,
        &#39;SWAP&#39;: lambda params: cirq.SWAP,
        &#39;ISWAP&#39;: lambda params: cirq.ISWAP,
        &#39;FSIM&#39;: lambda params: cirq.FSimGate(*params),
        &#39;CPHASE&#39;: lambda params: cirq.CZ**(params[0] / np.pi)
    }

    # Get circuit
    circ = cirq.Circuit()

    # If not provided, create trivial map
    if not qubits_map:
        try:
            sorted(circuit.all_qubits())
            _standard_sortable = True
        except:
            _standard_sortable = False

        if _standard_sortable:
            qubits_map = {q: cirq.LineQubit(q) for q in circuit.all_qubits()}
        else:
            qubits_map = {
                q: cirq.LineQubit(x) for x, q in enumerate(circuit.all_qubits())
            }

    # Apply gates
    for gate in tqdm(circuit, disable=not verbose):

        # Check if qubits are missing
        if not gate.provides(&#39;qubits&#39;) or gate.qubits is None:
            raise ValueError(
                f&#34;Gate(name=&#39;{gate.name}&#39;) requires {gate.n_qubits} qubits.&#34;)

        # Check if params are missing
        if gate.provides(&#39;params&#39;) and gate.params is None:
            raise ValueError(
                f&#34;Gate(name=&#39;{gate.name}&#39;) requires {gate.n_params} parameters.&#34;
            )

        # Get mapped qubits
        qubits = [qubits_map[q] for q in gate.qubits]

        # Get params
        params = gate.params if gate.provides(&#39;params&#39;) else None

        if gate.name in {
                &#39;MATRIX&#39;, &#39;U3&#39;, &#39;R_PI_2&#39;
        } or (gate.provides(&#39;is_conjugated&#39;) and
              gate.is_conjugated()) or (gate.provides(&#39;is_transposed&#39;) and
                                        gate.is_transposed()):
            cirq_gate = cirq.MatrixGate(gate.matrix())
        elif gate.name[:5] == &#39;SQRT_&#39;:
            cirq_gate = _to_cirq_naming[gate.name[5:]](params)**(0.5 *
                                                                 gate.power)
        elif gate.name in _to_cirq_naming:
            cirq_gate = _to_cirq_naming[gate.name](params)**gate.power
        else:
            raise ValueError(f&#34;{gate} not yet supported.&#34;)

        # Append
        circ.append(cirq_gate.on(*qubits))

    return circ</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hybridq.extras.io.cirq.to_cirq"><code class="name flex">
<span>def <span class="ident">to_cirq</span></span>(<span>circuit: Circuit, qubits_map: dict[any, any] = None, verbose: bool = False) ‑> cirq.Circuit</span>
</code></dt>
<dd>
<div class="desc"><p>Convert <code>Circuit</code> to <code>cirq.Circuit</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>circuit</code></strong> :&ensp;<code>Circuit</code></dt>
<dd><code>Circuit</code> to convert to <code>cirq.Circuit</code>.</dd>
<dt><strong><code>qubits_map</code></strong> :&ensp;<code>dict[any, any]</code>, optional</dt>
<dd>How to map qubits in <code>Circuit</code> to <code>cirq.Circuit</code>. if not provided,
<code>cirq.LineQubit</code>s are used and automatically mapped to <code>Circuit</code>'s
qubits.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Verbose output.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>cirq.Circuit</code></dt>
<dd><code>cirq.Circuit</code> obtained from <code>Circuit</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hybridq.extras.cirq import to_cirq
&gt;&gt;&gt; c = Circuit(Gate('H', qubits=[q]) for q in range(3))
&gt;&gt;&gt; c.append(Gate('CX', qubits=[0, 1]))
&gt;&gt;&gt; c.append(Gate('CX', qubits=[2, 0]))
&gt;&gt;&gt; c.append(Gate('CX', qubits=[1, 2]))
&gt;&gt;&gt; to_cirq(c)
0: ───H───@───X───────
          │   │
1: ───H───X───┼───@───
              │   │
2: ───H───────@───X───
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_cirq(circuit: Circuit,
            qubits_map: dict[any, any] = None,
            verbose: bool = False) -&gt; cirq.Circuit:
    &#34;&#34;&#34;
    Convert `Circuit` to `cirq.Circuit`.

    Parameters
    ----------
    circuit: Circuit
        `Circuit` to convert to `cirq.Circuit`.
    qubits_map: dict[any, any], optional
        How to map qubits in `Circuit` to `cirq.Circuit`. if not provided,
        `cirq.LineQubit`s are used and automatically mapped to `Circuit`&#39;s
        qubits.
    verbose: bool, optional
        Verbose output.

    Returns
    -------
    cirq.Circuit
        `cirq.Circuit` obtained from `Circuit`.

    Example
    -------
    &gt;&gt;&gt; from hybridq.extras.cirq import to_cirq
    &gt;&gt;&gt; c = Circuit(Gate(&#39;H&#39;, qubits=[q]) for q in range(3))
    &gt;&gt;&gt; c.append(Gate(&#39;CX&#39;, qubits=[0, 1]))
    &gt;&gt;&gt; c.append(Gate(&#39;CX&#39;, qubits=[2, 0]))
    &gt;&gt;&gt; c.append(Gate(&#39;CX&#39;, qubits=[1, 2]))
    &gt;&gt;&gt; to_cirq(c)
    0: ───H───@───X───────
              │   │
    1: ───H───X───┼───@───
                  │   │
    2: ───H───────@───X───
    &#34;&#34;&#34;

    _to_cirq_naming = {
        &#39;I&#39;: lambda params: cirq.I,
        &#39;P&#39;: lambda params: cirq.S,
        &#39;T&#39;: lambda params: cirq.T,
        &#39;X&#39;: lambda params: cirq.X,
        &#39;Y&#39;: lambda params: cirq.Y,
        &#39;Z&#39;: lambda params: cirq.Z,
        &#39;H&#39;: lambda params: cirq.H,
        &#39;RX&#39;: lambda params: cirq.rx(*params),
        &#39;RY&#39;: lambda params: cirq.ry(*params),
        &#39;RZ&#39;: lambda params: cirq.rz(*params),
        &#39;CZ&#39;: lambda params: cirq.CZ,
        &#39;ZZ&#39;: lambda params: cirq.ZZ,
        &#39;CX&#39;: lambda params: cirq.CNOT,
        &#39;SWAP&#39;: lambda params: cirq.SWAP,
        &#39;ISWAP&#39;: lambda params: cirq.ISWAP,
        &#39;FSIM&#39;: lambda params: cirq.FSimGate(*params),
        &#39;CPHASE&#39;: lambda params: cirq.CZ**(params[0] / np.pi)
    }

    # Get circuit
    circ = cirq.Circuit()

    # If not provided, create trivial map
    if not qubits_map:
        try:
            sorted(circuit.all_qubits())
            _standard_sortable = True
        except:
            _standard_sortable = False

        if _standard_sortable:
            qubits_map = {q: cirq.LineQubit(q) for q in circuit.all_qubits()}
        else:
            qubits_map = {
                q: cirq.LineQubit(x) for x, q in enumerate(circuit.all_qubits())
            }

    # Apply gates
    for gate in tqdm(circuit, disable=not verbose):

        # Check if qubits are missing
        if not gate.provides(&#39;qubits&#39;) or gate.qubits is None:
            raise ValueError(
                f&#34;Gate(name=&#39;{gate.name}&#39;) requires {gate.n_qubits} qubits.&#34;)

        # Check if params are missing
        if gate.provides(&#39;params&#39;) and gate.params is None:
            raise ValueError(
                f&#34;Gate(name=&#39;{gate.name}&#39;) requires {gate.n_params} parameters.&#34;
            )

        # Get mapped qubits
        qubits = [qubits_map[q] for q in gate.qubits]

        # Get params
        params = gate.params if gate.provides(&#39;params&#39;) else None

        if gate.name in {
                &#39;MATRIX&#39;, &#39;U3&#39;, &#39;R_PI_2&#39;
        } or (gate.provides(&#39;is_conjugated&#39;) and
              gate.is_conjugated()) or (gate.provides(&#39;is_transposed&#39;) and
                                        gate.is_transposed()):
            cirq_gate = cirq.MatrixGate(gate.matrix())
        elif gate.name[:5] == &#39;SQRT_&#39;:
            cirq_gate = _to_cirq_naming[gate.name[5:]](params)**(0.5 *
                                                                 gate.power)
        elif gate.name in _to_cirq_naming:
            cirq_gate = _to_cirq_naming[gate.name](params)**gate.power
        else:
            raise ValueError(f&#34;{gate} not yet supported.&#34;)

        # Append
        circ.append(cirq_gate.on(*qubits))

    return circ</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq.extras.io" href="index.html">hybridq.extras.io</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hybridq.extras.io.cirq.to_cirq" href="#hybridq.extras.io.cirq.to_cirq">to_cirq</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>