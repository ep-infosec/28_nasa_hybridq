<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hybridq.utils.aligned.aligned_array API documentation</title>
<meta name="description" content="Author: Salvatore Mandra (salvatore.mandra@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.utils.aligned.aligned_array</code></h1>
</header>
<section id="section-intro">
<p>Author: Salvatore Mandra (salvatore.mandra@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Salvatore Mandra (salvatore.mandra@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
from hybridq.utils.utils import isintegral
import numpy as np


def isaligned(a: np.ndarray, alignment: int) -&gt; bool:
    &#34;&#34;&#34;
    Return `True` if `a` is aligned with `alignment`.

    Parameters
    ----------
    a: np.ndarray
        Array to check the alignment.
    alignment: int
        The desired alignment.

    Returns
    -------
    bool
        `True` is `a` is aligned to `alignment`, and `False` otherwise.
    &#34;&#34;&#34;
    return (a.ctypes.data % alignment) == 0


def get_alignment(a: np.ndarray, max_alignment: int = 128) -&gt; int:
    &#34;&#34;&#34;
    Get the largest alignment for `a`, up to `max_alignment`.

    Parameters
    ----------
    a: np.ndarray
        Array to get the alignment.
    max_alignment: int, optional
        Maximum alignment to check.

    Returns
    -------
    int
        The maximum alignment of `a`, up to `max_alignment`.
    &#34;&#34;&#34;
    # Check max_alignment
    if bin(max_alignment).count(&#39;1&#39;) != 1:
        raise ValueError(&#34;&#39;max_alignment&#39; must be a power of 2.&#34;)

    # Get largest base
    b = int(np.log2(max_alignment))

    # Get best alignment
    return next(2**x for x in range(b, 0, -1) if (a.ctypes.data % 2**x) == 0)


def empty(shape: any,
          dtype: any = float,
          order: {&#39;C&#39;, &#39;F&#39;} = &#39;C&#39;,
          *,
          alignment: int = 16,
          **kwargs):
    &#34;&#34;&#34;
    Return an `np.ndarray` which is aligned to the given `alignment`.

    Parameters
    ----------
    shape: any
        The shape of the new array.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;}, optional
        Memory layout.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    numpy
    &#34;&#34;&#34;
    # Set defaults
    kwargs.setdefault(&#39;__gen__&#39;, np.empty)

    # Get dtype, size and alignment
    dtype = np.dtype(dtype)
    shape = int(shape) if isintegral(shape) else tuple(map(int, shape))
    size = np.prod(shape)
    order = str(order)
    alignment = int(alignment)

    # Check order
    if order not in list(&#39;FC&#39;):
        raise ValueError(f&#34;&#39;{order}&#39; is not a valid order.&#34;)

    # Check alignment is compatible
    if alignment % dtype.itemsize:
        raise ValueError(
            f&#34;{dtype} is not compatible with &#39;alignment={alignment}&#39;&#34;)

    # Get max_shift
    max_shift = alignment // dtype.itemsize

    # Get new buffer
    buffer = kwargs[&#39;__gen__&#39;]((size + max_shift,), dtype=dtype, order=order)

    # Get right shift
    shift = (alignment - (buffer.ctypes.data % alignment)) // dtype.itemsize
    assert (shift &lt;= max_shift)

    # Re-align if needed
    buffer = buffer[shift:size + shift]

    # Check alignment
    assert (buffer.ctypes.data % alignment == 0)

    # Reshape
    buffer = np.reshape(buffer, shape, order=order)

    # Check alignment before returning
    assert (buffer.ctypes.data % alignment == 0)

    # Return buffer
    return buffer


def zeros(shape: any,
          dtype: any = float,
          order: {&#39;C&#39;, &#39;F&#39;} = &#39;C&#39;,
          *,
          alignment: int = 16,
          **kwargs):
    &#34;&#34;&#34;
    Return an `np.ndarray` of zeros which is aligned to the given `alignment`.

    Parameters
    ----------
    shape: any
        The shape of the new array.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;}, optional
        Memory layout.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    hybridq.utils.aligned.empty
    &#34;&#34;&#34;
    return empty(shape=shape,
                 dtype=dtype,
                 order=order,
                 alignment=alignment,
                 __gen__=np.zeros)


def ones(shape: any,
         dtype: any = float,
         order: {&#39;C&#39;, &#39;F&#39;} = &#39;C&#39;,
         *,
         alignment: int = 16,
         **kwargs):
    &#34;&#34;&#34;
    Return an `np.ndarray` of ones which is aligned to the given `alignment`.

    Parameters
    ----------
    shape: any
        The shape of the new array.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;}, optional
        Memory layout.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    hybridq.utils.aligned.empty
    &#34;&#34;&#34;
    return empty(shape=shape,
                 dtype=dtype,
                 order=order,
                 alignment=alignment,
                 __gen__=np.ones)


def empty_like(a: np.array) -&gt; np.array:
    # Get params
    shape = a.shape
    dtype = a.dtype
    order = &#39;C&#39; if a.flags.c_contiguous else &#39;F&#39;
    alignment = get_alignment(a)

    # Return
    return empty(shape=shape, dtype=dtype, order=order, alignment=alignment)


def zeros_like(a: np.array) -&gt; np.array:
    # Get params
    shape = a.shape
    dtype = a.dtype
    order = &#39;C&#39; if a.flags.c_contiguous else &#39;F&#39;
    alignment = get_alignment(a)

    # Return
    return zeros(shape=shape, dtype=dtype, order=order, alignment=alignment)


def ones_like(a: np.array) -&gt; np.array:
    # Get params
    shape = a.shape
    dtype = a.dtype
    order = &#39;C&#39; if a.flags.c_contiguous else &#39;F&#39;
    alignment = get_alignment(a)

    # Return
    return ones(shape=shape, dtype=dtype, order=order, alignment=alignment)


def array(a: any,
          dtype: any = None,
          order: {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;} = &#39;K&#39;,
          *,
          alignment: int = 16,
          copy: bool = True,
          **kwargs) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Return a copy of `a` which is aligned to the given `alignment`.

    Parameters
    ----------
    a: any
        Array to align.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional
        Memory layout.  &#39;A&#39; and &#39;K&#39; depend on the order of input array a.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        &#39;A&#39; (any) means &#39;F&#39; if `a` is Fortran contiguous, &#39;C&#39; otherwise
        &#39;K&#39; (keep) preserve input order.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.
    copy: bool, optional
        It copies `a` to a new array even if `a` is already aligned.
        (default: `True`)

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    numpy, hybridq.utils.aligned.empty
    &#34;&#34;&#34;

    # Store reference to the original array
    _a = a

    # Get array
    a = np.asarray(_a, dtype=dtype, order=order)

    # Check if a new copy is created
    _new = a is not _a

    # Get dtype, size and alignment
    dtype = a.dtype
    shape = a.shape
    size = np.prod(shape)
    order = &#39;C&#39; if a.flags.c_contiguous else &#39;F&#39;
    alignment = int(alignment)

    # Check alignment is compatible
    if alignment % dtype.itemsize:
        raise ValueError(
            f&#34;{dtype} is not compatible with &#39;alignment={alignment}&#39;&#34;)

    # If new, check alignment and eventually return if already aligned
    if (_new or not copy) and isaligned(a, alignment=alignment):
        return a

    # Get max_shift
    max_shift = alignment // dtype.itemsize

    # If _new, resize
    if _new:
        # Resize memory
        a.resize(size + max_shift)

        # Reference to buffer
        buffer = a

        # Return to the orginal size
        a = a[:size]

    # Otherwise, get new buffer
    else:
        buffer = np.empty((size + max_shift,), dtype=dtype, order=order)

    # Get right shift
    shift = (alignment - (buffer.ctypes.data % alignment)) // dtype.itemsize
    assert (shift &lt;= max_shift)

    # Re-align if needed
    buffer = buffer[shift:size + shift]

    # Reshape
    buffer = np.reshape(buffer, shape, order=order)

    # Check alignment
    assert (isaligned(buffer, alignment=alignment))

    # Copy if a was provided
    np.copyto(buffer, np.reshape(a, shape, order=order))

    # Return buffer
    return buffer


def asarray(a: any,
            dtype: any = None,
            order: {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;} = &#39;K&#39;,
            *,
            alignment: int = 16,
            **kwargs) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Convert `a` to an aligned array with the given `alignment`.

    Parameters
    ----------
    a: any, optional
        Array to align.
    shape: any, optional
        The shape of the new array.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional
        Memory layout.  &#39;A&#39; and &#39;K&#39; depend on the order of input array a.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        &#39;A&#39; (any) means &#39;F&#39; if `a` is Fortran contiguous, &#39;C&#39; otherwise
        &#39;K&#39; (keep) preserve input order.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    numpy, hybridq.utils.aligned.empty
    &#34;&#34;&#34;

    return array(a=a, dtype=dtype, order=order, alignment=alignment, copy=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hybridq.utils.aligned.aligned_array.array"><code class="name flex">
<span>def <span class="ident">array</span></span>(<span>a: any, dtype: any = None, order: "{'C', 'F', 'A', 'K'}" = 'K', *, alignment: int = 16, copy: bool = True, **kwargs) ‑> np.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return a copy of <code>a</code> which is aligned to the given <code>alignment</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>any</code></dt>
<dd>Array to align.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>The type of the new array.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{'C', 'F', 'A', 'K'}</code>, optional</dt>
<dd>Memory layout.
'A' and 'K' depend on the order of input array a.
'C' row-major (C-style),
'F' column-major (Fortran-style) memory representation.
'A' (any) means 'F' if <code>a</code> is Fortran contiguous, 'C' otherwise
'K' (keep) preserve input order.
Defaults to 'C'.</dd>
<dt><strong><code>alignment</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The required alignment.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>It copies <code>a</code> to a new array even if <code>a</code> is already aligned.
(default: <code>True</code>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The aligned array.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>numpy</code>, <code>hybridq.utils.aligned.empty</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array(a: any,
          dtype: any = None,
          order: {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;} = &#39;K&#39;,
          *,
          alignment: int = 16,
          copy: bool = True,
          **kwargs) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Return a copy of `a` which is aligned to the given `alignment`.

    Parameters
    ----------
    a: any
        Array to align.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional
        Memory layout.  &#39;A&#39; and &#39;K&#39; depend on the order of input array a.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        &#39;A&#39; (any) means &#39;F&#39; if `a` is Fortran contiguous, &#39;C&#39; otherwise
        &#39;K&#39; (keep) preserve input order.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.
    copy: bool, optional
        It copies `a` to a new array even if `a` is already aligned.
        (default: `True`)

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    numpy, hybridq.utils.aligned.empty
    &#34;&#34;&#34;

    # Store reference to the original array
    _a = a

    # Get array
    a = np.asarray(_a, dtype=dtype, order=order)

    # Check if a new copy is created
    _new = a is not _a

    # Get dtype, size and alignment
    dtype = a.dtype
    shape = a.shape
    size = np.prod(shape)
    order = &#39;C&#39; if a.flags.c_contiguous else &#39;F&#39;
    alignment = int(alignment)

    # Check alignment is compatible
    if alignment % dtype.itemsize:
        raise ValueError(
            f&#34;{dtype} is not compatible with &#39;alignment={alignment}&#39;&#34;)

    # If new, check alignment and eventually return if already aligned
    if (_new or not copy) and isaligned(a, alignment=alignment):
        return a

    # Get max_shift
    max_shift = alignment // dtype.itemsize

    # If _new, resize
    if _new:
        # Resize memory
        a.resize(size + max_shift)

        # Reference to buffer
        buffer = a

        # Return to the orginal size
        a = a[:size]

    # Otherwise, get new buffer
    else:
        buffer = np.empty((size + max_shift,), dtype=dtype, order=order)

    # Get right shift
    shift = (alignment - (buffer.ctypes.data % alignment)) // dtype.itemsize
    assert (shift &lt;= max_shift)

    # Re-align if needed
    buffer = buffer[shift:size + shift]

    # Reshape
    buffer = np.reshape(buffer, shape, order=order)

    # Check alignment
    assert (isaligned(buffer, alignment=alignment))

    # Copy if a was provided
    np.copyto(buffer, np.reshape(a, shape, order=order))

    # Return buffer
    return buffer</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.asarray"><code class="name flex">
<span>def <span class="ident">asarray</span></span>(<span>a: any, dtype: any = None, order: "{'C', 'F', 'A', 'K'}" = 'K', *, alignment: int = 16, **kwargs) ‑> np.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Convert <code>a</code> to an aligned array with the given <code>alignment</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>Array to align.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>The shape of the new array.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>The type of the new array.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{'C', 'F', 'A', 'K'}</code>, optional</dt>
<dd>Memory layout.
'A' and 'K' depend on the order of input array a.
'C' row-major (C-style),
'F' column-major (Fortran-style) memory representation.
'A' (any) means 'F' if <code>a</code> is Fortran contiguous, 'C' otherwise
'K' (keep) preserve input order.
Defaults to 'C'.</dd>
<dt><strong><code>alignment</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The required alignment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The aligned array.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>numpy</code>, <code>hybridq.utils.aligned.empty</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asarray(a: any,
            dtype: any = None,
            order: {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;} = &#39;K&#39;,
            *,
            alignment: int = 16,
            **kwargs) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Convert `a` to an aligned array with the given `alignment`.

    Parameters
    ----------
    a: any, optional
        Array to align.
    shape: any, optional
        The shape of the new array.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional
        Memory layout.  &#39;A&#39; and &#39;K&#39; depend on the order of input array a.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        &#39;A&#39; (any) means &#39;F&#39; if `a` is Fortran contiguous, &#39;C&#39; otherwise
        &#39;K&#39; (keep) preserve input order.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    numpy, hybridq.utils.aligned.empty
    &#34;&#34;&#34;

    return array(a=a, dtype=dtype, order=order, alignment=alignment, copy=False)</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>shape: any, dtype: any = builtins.float, order: "{'C', 'F'}" = 'C', *, alignment: int = 16, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an <code>np.ndarray</code> which is aligned to the given <code>alignment</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>any</code></dt>
<dd>The shape of the new array.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>The type of the new array.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{'C', 'F'}</code>, optional</dt>
<dd>Memory layout.
'C' row-major (C-style),
'F' column-major (Fortran-style) memory representation.
Defaults to 'C'.</dd>
<dt><strong><code>alignment</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The required alignment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The aligned array.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>numpy</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty(shape: any,
          dtype: any = float,
          order: {&#39;C&#39;, &#39;F&#39;} = &#39;C&#39;,
          *,
          alignment: int = 16,
          **kwargs):
    &#34;&#34;&#34;
    Return an `np.ndarray` which is aligned to the given `alignment`.

    Parameters
    ----------
    shape: any
        The shape of the new array.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;}, optional
        Memory layout.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    numpy
    &#34;&#34;&#34;
    # Set defaults
    kwargs.setdefault(&#39;__gen__&#39;, np.empty)

    # Get dtype, size and alignment
    dtype = np.dtype(dtype)
    shape = int(shape) if isintegral(shape) else tuple(map(int, shape))
    size = np.prod(shape)
    order = str(order)
    alignment = int(alignment)

    # Check order
    if order not in list(&#39;FC&#39;):
        raise ValueError(f&#34;&#39;{order}&#39; is not a valid order.&#34;)

    # Check alignment is compatible
    if alignment % dtype.itemsize:
        raise ValueError(
            f&#34;{dtype} is not compatible with &#39;alignment={alignment}&#39;&#34;)

    # Get max_shift
    max_shift = alignment // dtype.itemsize

    # Get new buffer
    buffer = kwargs[&#39;__gen__&#39;]((size + max_shift,), dtype=dtype, order=order)

    # Get right shift
    shift = (alignment - (buffer.ctypes.data % alignment)) // dtype.itemsize
    assert (shift &lt;= max_shift)

    # Re-align if needed
    buffer = buffer[shift:size + shift]

    # Check alignment
    assert (buffer.ctypes.data % alignment == 0)

    # Reshape
    buffer = np.reshape(buffer, shape, order=order)

    # Check alignment before returning
    assert (buffer.ctypes.data % alignment == 0)

    # Return buffer
    return buffer</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.empty_like"><code class="name flex">
<span>def <span class="ident">empty_like</span></span>(<span>a: np.array) ‑> <built-in function <a title="hybridq.utils.aligned.aligned_array.array" href="#hybridq.utils.aligned.aligned_array.array">array()</a>></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty_like(a: np.array) -&gt; np.array:
    # Get params
    shape = a.shape
    dtype = a.dtype
    order = &#39;C&#39; if a.flags.c_contiguous else &#39;F&#39;
    alignment = get_alignment(a)

    # Return
    return empty(shape=shape, dtype=dtype, order=order, alignment=alignment)</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.get_alignment"><code class="name flex">
<span>def <span class="ident">get_alignment</span></span>(<span>a: np.ndarray, max_alignment: int = 128) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Get the largest alignment for <code>a</code>, up to <code>max_alignment</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Array to get the alignment.</dd>
<dt><strong><code>max_alignment</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum alignment to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The maximum alignment of <code>a</code>, up to <code>max_alignment</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alignment(a: np.ndarray, max_alignment: int = 128) -&gt; int:
    &#34;&#34;&#34;
    Get the largest alignment for `a`, up to `max_alignment`.

    Parameters
    ----------
    a: np.ndarray
        Array to get the alignment.
    max_alignment: int, optional
        Maximum alignment to check.

    Returns
    -------
    int
        The maximum alignment of `a`, up to `max_alignment`.
    &#34;&#34;&#34;
    # Check max_alignment
    if bin(max_alignment).count(&#39;1&#39;) != 1:
        raise ValueError(&#34;&#39;max_alignment&#39; must be a power of 2.&#34;)

    # Get largest base
    b = int(np.log2(max_alignment))

    # Get best alignment
    return next(2**x for x in range(b, 0, -1) if (a.ctypes.data % 2**x) == 0)</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.isaligned"><code class="name flex">
<span>def <span class="ident">isaligned</span></span>(<span>a: np.ndarray, alignment: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>a</code> is aligned with <code>alignment</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Array to check the alignment.</dd>
<dt><strong><code>alignment</code></strong> :&ensp;<code>int</code></dt>
<dd>The desired alignment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> is <code>a</code> is aligned to <code>alignment</code>, and <code>False</code> otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isaligned(a: np.ndarray, alignment: int) -&gt; bool:
    &#34;&#34;&#34;
    Return `True` if `a` is aligned with `alignment`.

    Parameters
    ----------
    a: np.ndarray
        Array to check the alignment.
    alignment: int
        The desired alignment.

    Returns
    -------
    bool
        `True` is `a` is aligned to `alignment`, and `False` otherwise.
    &#34;&#34;&#34;
    return (a.ctypes.data % alignment) == 0</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.ones"><code class="name flex">
<span>def <span class="ident">ones</span></span>(<span>shape: any, dtype: any = builtins.float, order: "{'C', 'F'}" = 'C', *, alignment: int = 16, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an <code>np.ndarray</code> of ones which is aligned to the given <code>alignment</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>any</code></dt>
<dd>The shape of the new array.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>The type of the new array.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{'C', 'F'}</code>, optional</dt>
<dd>Memory layout.
'C' row-major (C-style),
'F' column-major (Fortran-style) memory representation.
Defaults to 'C'.</dd>
<dt><strong><code>alignment</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The required alignment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The aligned array.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>hybridq.utils.aligned.empty</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ones(shape: any,
         dtype: any = float,
         order: {&#39;C&#39;, &#39;F&#39;} = &#39;C&#39;,
         *,
         alignment: int = 16,
         **kwargs):
    &#34;&#34;&#34;
    Return an `np.ndarray` of ones which is aligned to the given `alignment`.

    Parameters
    ----------
    shape: any
        The shape of the new array.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;}, optional
        Memory layout.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    hybridq.utils.aligned.empty
    &#34;&#34;&#34;
    return empty(shape=shape,
                 dtype=dtype,
                 order=order,
                 alignment=alignment,
                 __gen__=np.ones)</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.ones_like"><code class="name flex">
<span>def <span class="ident">ones_like</span></span>(<span>a: np.array) ‑> <built-in function <a title="hybridq.utils.aligned.aligned_array.array" href="#hybridq.utils.aligned.aligned_array.array">array()</a>></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ones_like(a: np.array) -&gt; np.array:
    # Get params
    shape = a.shape
    dtype = a.dtype
    order = &#39;C&#39; if a.flags.c_contiguous else &#39;F&#39;
    alignment = get_alignment(a)

    # Return
    return ones(shape=shape, dtype=dtype, order=order, alignment=alignment)</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.zeros"><code class="name flex">
<span>def <span class="ident">zeros</span></span>(<span>shape: any, dtype: any = builtins.float, order: "{'C', 'F'}" = 'C', *, alignment: int = 16, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an <code>np.ndarray</code> of zeros which is aligned to the given <code>alignment</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>any</code></dt>
<dd>The shape of the new array.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>The type of the new array.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{'C', 'F'}</code>, optional</dt>
<dd>Memory layout.
'C' row-major (C-style),
'F' column-major (Fortran-style) memory representation.
Defaults to 'C'.</dd>
<dt><strong><code>alignment</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The required alignment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The aligned array.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>hybridq.utils.aligned.empty</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zeros(shape: any,
          dtype: any = float,
          order: {&#39;C&#39;, &#39;F&#39;} = &#39;C&#39;,
          *,
          alignment: int = 16,
          **kwargs):
    &#34;&#34;&#34;
    Return an `np.ndarray` of zeros which is aligned to the given `alignment`.

    Parameters
    ----------
    shape: any
        The shape of the new array.
    dtype: any, optional
        The type of the new array.
    order : {&#39;C&#39;, &#39;F&#39;}, optional
        Memory layout.
        &#39;C&#39; row-major (C-style),
        &#39;F&#39; column-major (Fortran-style) memory representation.
        Defaults to &#39;C&#39;.
    alignment: int, optional
        The required alignment.

    Returns
    -------
    np.ndarray
        The aligned array.

    See Also
    --------
    hybridq.utils.aligned.empty
    &#34;&#34;&#34;
    return empty(shape=shape,
                 dtype=dtype,
                 order=order,
                 alignment=alignment,
                 __gen__=np.zeros)</code></pre>
</details>
</dd>
<dt id="hybridq.utils.aligned.aligned_array.zeros_like"><code class="name flex">
<span>def <span class="ident">zeros_like</span></span>(<span>a: np.array) ‑> <built-in function <a title="hybridq.utils.aligned.aligned_array.array" href="#hybridq.utils.aligned.aligned_array.array">array()</a>></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zeros_like(a: np.array) -&gt; np.array:
    # Get params
    shape = a.shape
    dtype = a.dtype
    order = &#39;C&#39; if a.flags.c_contiguous else &#39;F&#39;
    alignment = get_alignment(a)

    # Return
    return zeros(shape=shape, dtype=dtype, order=order, alignment=alignment)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq.utils.aligned" href="index.html">hybridq.utils.aligned</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="hybridq.utils.aligned.aligned_array.array" href="#hybridq.utils.aligned.aligned_array.array">array</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.asarray" href="#hybridq.utils.aligned.aligned_array.asarray">asarray</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.empty" href="#hybridq.utils.aligned.aligned_array.empty">empty</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.empty_like" href="#hybridq.utils.aligned.aligned_array.empty_like">empty_like</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.get_alignment" href="#hybridq.utils.aligned.aligned_array.get_alignment">get_alignment</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.isaligned" href="#hybridq.utils.aligned.aligned_array.isaligned">isaligned</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.ones" href="#hybridq.utils.aligned.aligned_array.ones">ones</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.ones_like" href="#hybridq.utils.aligned.aligned_array.ones_like">ones_like</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.zeros" href="#hybridq.utils.aligned.aligned_array.zeros">zeros</a></code></li>
<li><code><a title="hybridq.utils.aligned.aligned_array.zeros_like" href="#hybridq.utils.aligned.aligned_array.zeros_like">zeros_like</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>